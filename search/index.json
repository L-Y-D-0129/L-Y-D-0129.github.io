[{"content":"","date":"2024-01-21T00:00:00Z","image":"https://L-Y-D-0129.github.io/p/redis/2109242356423Y8-0-lp_hu14192924914521109729.jpg","permalink":"https://L-Y-D-0129.github.io/p/redis/","title":"Redis"},{"content":"C++知识点 C语言与C++的区别 C语言没有bool类型 C++有 C++可以重载和c没有\n这是因为C++的编译器在编译的时候会带着函数参数的类型 C语言不会 C++是面向对象编程 C是面向过程\nC++ 变量检测增强 例如 在全局 定义一个变量 为 int a； 然后还在全局对他初始化 int a=4；这时会报错 但C不会\n默认返回值不同 在c++中若函数没有返回值 则必须指定为void c没有的话默认为int\nC++有缺省参数 c没有\nC语言中作用域只有两个：局部，全局。C++中则是有：局部作用域，类作用域，名字空间作用域三种。\n菱形继承 类A,类B，类C都继承A，然后类D继承自类和类C，\n会产生数据冗余 类A有一些数据成员，类B和类C继承于A，类B和类C都会有一份自类A的数据副本，当类D继承自类B和类C时，类D实际会有两份来自类A的数据副本，造成数据冗余。\n二义性 当类 D 中调用一个在类 A 中定义的方法时，由于类 D 有两条通过类 B 和类 C 到达类 A 的继承路径，编译器无法确定应该使用哪一条路径上的方法，从而导致二义性问题。\n可以通过虚继承来解决菱形继承 用类B和类C以虚继承的方式继承类A时，类D只会有一份来自类A的数据副本。\nmalloc是如何分配内存的 1.通过brk系统调用从堆分配内存\n2.通过mmap系统调用在文件映射区域分配内存\nmalloc分配的是虚拟内存\n他会预分配更大的空间作为内存池\nmalloc通过brk方式申请的内存，free释放的时候，并不会把内存归还给操作系统，而是缓存在malloc的内存池中\nmalloc通过mmap方式申请的内存，free释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。\nvolatile关键字 提醒编译器他后面所定义的变量随时都有可能被改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值\nC++将引用作为返回值的好处和应该遵守的规则 减少内存开销 提高效率 支持链式操作 注意不能返回局部变量的引用 union和struct的区别 struct 各成员拥有自己的内存，各自使用互不干涉，同时存在遵循内存对齐原则，一个struct变量总长度等于所有成员的长度之和\nunion 各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权，各变量共用一个内存首地址，联合体比结构体更节约内存，一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。 在赋值的时候，对于union的不同成员赋值，将会对其他成员进行重写，原来成员的值就不存在了，而对于struct的不同成员赋值是互不影响的。\n四种强制类型转换 static_cast 用于将一种数据类型强制转换为另一种数据类型\nconst_cast 用于强制去掉不能被修改的常数特性，但需要特别主义的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。\nreinterpret_cast 改变指针或引用的类型，指针或引用转换为一个足够长度的整形，将整形转换为指针或引用类型\ndynamic_cast 将基类的指针或引用安全地转换成派生类的指针或引用，并用派生类的指针或引用调用非虚函数。如果是基类指针或引用调用的是虚函数无需转换就能在运行时调用派生类的虚函数\ndynamic_cast 的实现原理涉及到一个名为 \u0026ldquo;vtable\u0026rdquo; 的虚函数表和一个名为 \u0026ldquo;type_info\u0026rdquo; 的运行时类型信息 (RTTI) 系统。\n迭代器失效 迭代器：是一个遍历各种容器内元素的访问。 它的底层是一个指针 类模板 迭代器失效：就是迭代器底层对应指针所指向的空间被销毁了，而使用一块已经被释放的空间，造成的后果是程序崩溃。 可能会引起的扩容操作都有可能导致迭代器失效，push_back什么的\nthis指针 this指针存在于类成员函数中，指向类对象的指针。this是一个关键字，同时也是一个指针常量。 成员函数调用时，传递了一个隐含的参数指向函数所在类对象的地址。\nthis在成员在成员函数的开始执行前构造，在成员的执行结束后清除。\n悬空指针是指向被释放内存的指针，而野指针是不确定其具体指向的指针\n用户态与内核态 内核态控制的是内核空间的资源管理，用户态访问的是用户空间内的资源 指令的划分 特权不同 用户态\u0026mdash;\u0026gt;内核态：唯一途径是通过中断、异常、陷入机制（访管指令） 内核态\u0026mdash;\u0026gt;用户态：设置程序状态字PSW\n于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。 线程切换只能在内核态完成，如果当前用户处于用户态，则必然引起用户态与内核态的切换，线程的调度是在内核态运行的，而线程中的代码是在用户态运行。 拷贝构造为什么参数必须传引用 原文链接：https://blog.csdn.net/xiao23597/article/details/131041511\n初始化参数列表有什么特点 只能在构造函数中使用\n初始化参数列表的初始化顺序和成员变量的顺序一致\n常量和引用在初始化参数列表中初始化\n初始化参数列表可以调用成员对象的构造函数\n当父类没有默认构造函数时，可以利用初始化参数列表调用父类的构造函数\n什么时候调用拷贝构造 用已经存在的对象初始化新的对象的时候\n当对象以值的形式作为函数的参数或返回值时\ndelete为什么先调用析构函数在调用free\n因为先调用free的话，会导致内存泄漏，free直接释放对象的内存了，并没有释放对象所指向的内存\n指针与引用 原文链接：https://blog.csdn.net/weixin_45805339/article/details/128205810\n引用与所引用的变量共用同一块内存空间\n函数指针 int（*p）（int,int）他可以接收add（int a，int b） p=add 函数的名字就是地址 { return a+b；}\nC++空类大小为什么为1 为了实现每个实例在内存中都有一个独一无二的地址，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。\nstrcpy，sprinty，memcpy的区别 1.操作对象不同 strcpy的操作对象均为字符串 memcpy的两个对象是两个可以任意可操作的内存地址，不限于数据类型。\n效率不同 memcpy最快，strcpy慢\n实现功能不同 strcpy主要实现字符串变量间的拷贝 sprintf主要实现其他数据类型格式到字符串的转化 memcpy主要是内存块间的拷贝\n拷贝构造函数调用时机 用已经存在的对象去初始化新对象\n作为函数参数和函数返回值\n如何只在堆区申请对象\n将析构函数私有化，编译器会检查析构函数是否可以被调用 栈区申请内存用alloca()\n在栈区的话将new和delete重载为私有化\nconst const修饰变量时表示变量不可以修改，但是可以通过指针来修改\nconst修饰函数时，表示为常函数，常函数内的this指针是const * const this 所以常函数不能修改成员变量，也不能调用非常函数，这些是因为他们的this指针不匹配\nconst他作为函数的返回值时，可以防止被修改。\n非常函数只能调用常函数，常函数可以调用非常函数也可以调用常函数\n常函数和非常函数是重载关系\nC++类对象的初始化顺序 基类初始化，成员类对象初始化，自身构造函数初始化\n常量指针 const int p 声明一个指向常量整数的指针，常量指针，指针p可以指向不同的内存地址，但所指向的整数不能通过p来修改。\nconst int a = 10;\nconst int b = 20;\nconst int p = \u0026amp;a;\n// *p = 15; // 错误，不能通过指针修改所指向的常量整数\np = \u0026amp;b; // 合法，可以改变指针指向的地址\n指针常量\nint * const p 指针常量是指针本身是常量，即指针一旦初始化指向一个地址后，就不能再指向其他地址，但可以通过该指针修改所指向对象的值。\nint c = 30;\nint d = 40;\nint * const p = \u0026amp;c;\n*p = 35; // 合法，可以通过指针修改所指向的值\n// p = \u0026amp;d; // 错误，不能改变指针\nStatic static修饰全局变量 如果想在头文件中定义全局变量，需要定义为静态全局变量，会防止重定义问题\nstatic修饰局部变量 只作用在局部作用域，只会被初始化一次，不会随着函数的结束而被释放。\nstatic修饰成员变量 静态成员变量在编译期间初始化\n公有的静态成员变量可以通过类名：：和对象名直接访问 存放在静态区\n静态成员变量在继承关系中父类和子类共享 必须在类外初始化，因为静态成员变量是属于类的，不是属于类的任何特定对象，这意味着无论创建了多少个类的实例，静态成员变量都只有一个副本，因此，他需要在类的外部初始化，以确保这个变量的唯一性。\nstatic修饰成员函数时 静态成员函数没有this指针，因此静态成员函数不能访问非静态成员变量 也不能调用非静态成员函数。\n抽象类为什么不能创建对象 这是因为纯虚函数在虚函数表里存放的地址为0\n友元函数和友元类 通过友元，一个普通函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元正确的使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性。\n如何用代码判断大小端存储？ 大端 字数据的高字节存储在低地址中\n小端 字数据的低字节存储在低地址中\n强制类型转换 int转为char 只会留下低地址的地方\n巧用联合体\n如何在类外访问私有成员 通过公有方法访问，使用友元函数或友元类，使用指针强制转换reinterpret_cast 面向过程语言 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。\n缺点：没有面向对象易维护、易复用、易扩展\n面向对象语言 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 在C++的面试中，面向对象编程（OOP）的概念和应用是经常被提及的话题。为了成功应对这类面试，你需要对OOP的基本原理、特性以及它们在C++中的实现方式有深入的理解。以下是一些常见的C++面向对象面试问题及其回答策略： 回答：面向对象编程是一种编程范式，它将现实世界中的事物抽象为对象，并使用类来定义这些对象的属性和行为。OOP的主要特性包括封装、继承和多态。通过OOP，我们可以创建模块化、可重用和可维护的代码。\n封装：封装是隐藏对象的属性和实现细节，仅对外提供公共接口的过程。这有助于保护数据的完整性和安全性，同时也提高了代码的可维护性。 继承：继承允许我们创建一个新的类（子类或派生类），它继承了一个或多个已存在的类（父类或基类）的属性和方法。这使得代码重用成为可能，并有助于建立类之间的层次结构。 多态：多态是面向对象编程的一个重要特性，它允许我们使用父类类型的引用或指针来调用子类的方法。这使得我们可以在运行时动态地确定要调用的方法，从而实现更灵活和可扩展的代码。 虚函数 多态 多态分静态多态和动态多态 静态多态是在编译期间产生的多态 而动态多态是在运行期间确定的多态 静态多态包含： 函数重载 运算符重载 函数模板\n动态多态包括： 父类指针或引用指向子类对象 并通过指针或引用调用重写函数\n动态多态调用过程 首先会通过父类指针或引用访问到子类对象中的虚表指针，然后通过虚表指针找到虚函数表 通过虚函数表存放的虚函数地址去调用虚函数\n虚函数表 一个类只有一个 在编译阶段被构造 所有对象共享同一个虚函数表\n虚函数表指针 当类中存在虚函数时，编译器会给类增加一个指针类型的变量 放到虚函数表中 创建对象时就会创建一个虚函数表指针，在构造函数被赋值，\n因为是在构造函数中被复赋值的 所以构造函数不可以为虚函数 析构函数可以是虚函数么？ 可以 如果产生多态的话 一定要设置虚函数否则在编译时，由于编译器会把父类和子类的构造函数统一命名，那么此时析构函数为函数隐藏，如果父类中的析构函数为虚函数，那么将在子类的析构函数中去调用父类的析构函数，以此来避免内存泄漏\n内联函数 提高效率 它可以将函数体直接嵌入到调用处，避免了常规函数 调用时的压栈，跳转等操作，如果程序的执行小于开辟栈帧等操作的时间有必要设置为内联函数\n不能过于复杂 递归或代码太长\n并非总是有效\n堆和栈 从内存角度上看 堆需要手动申请释放内存 在C++中一般用 new delete c中用 malloc free 栈区的对象不需要回收 由操作系统进行回收 栈的申请速度和释放比堆快的多 因为他是由操作系统来操作的 栈的地址是高地址向低地址增长，堆的地址是低地址向高地址增长的\n从数据结构上看 堆分为 最大堆和最小堆 栈 先进后出\nnew malloc new是在堆区申请内存的 如果给类和结构体申请内存的话 会先调用malloc在调用构造函数 利用new创建的数据 返回数据对应的类型的指针\n释放new申请的内存需要时候delete 如果是数组delete[] 当这个类的析构函数没有作用时 也可以使用free释放new申请的堆区空间\nnew和malloc的区别 new 会先执行malloc 在执行构造函数给成员变量赋值 delete 先会执行析构函数 在执行free\nnew 返回值不需要强转 malloc 返回值需要强转\nnew 是运算符 malloc是c语言库函数\nnew 不需要传入具体的字节个数 malloc 需要传具体字节个数\nnew 会先执行malloc 在执行 构造函数给成员变量赋值 malloc 只分配堆区\nnew 申请失败会抛出异常 malloc会返回空\nnew可以重载因为是运算符\nfinal关键字 修饰虚函数，可以阻止子类重写父类这个函数。修饰类的话，表示不允许被继承\n移动语义 移动语义可以通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建，拷贝以及销毁，大幅度提高性能，正常用对象初始化对象时会调用拷贝构造，如果这个对象占的堆区内存很大，就可以用右值引用进行性能优化。\n深拷贝浅拷贝 浅拷贝（Shallow Copy） 是指在拷贝对象时，只是复制了对象中的成员变量的值的引用或指针。浅拷贝后的对象和原对象共享一份数据，修改一个对象可能会影响另一个对象。\n深拷贝（Deep Copy） 是指在拷贝对象时，会创建一个新的独立的对象，并复制原对象中的所有成员变量的值。深拷贝后的对象和原对象是完全独立的，修改一个对象不会影响另一个对象。\nauto auto 让编译器通过初始值来进行类型推演，从而获得定义变量的类型，所以说auto定义的变量必须由初始值。\ndecltype 它的作用是选择并返回操作数的数据类型，在此过程中，编译器只是分析表达式并得到它的类型，去不进行实际的计算表达式的值。\nLambda 相当于一个内嵌的匿名函数，用于替换独立函数或者函数对象。\n返回值，编译器会根据return语句自动推导返回值类型，但是需要主义的是lambda表达式不能通过列表初始化自动推导返回值类型，像vector，list这种。\nsizeof捕获列表：如果lambda捕获了一些外部变量，它的大小将包含这些捕获变量的大小，每个捕获的变量都会在lambda的内部定义一个数据成员\n状态：如果lambda没有捕获任何变量，则其大小通常是固定的，1字节。因为编译器需要给每个lambda表达式生成一个独特的类。\n智能指针 智能指针的底层实现原理主要依赖于引用计数和RAII（‌资源获取即初始化）‌原则。\nRALL：是C++语言的一种管理资源、避免资源泄漏的惯用法，利用栈对象自动销毁的特点来实现，这一概念最早由Bjarne Stroustrup提出。因此，我们可以通过构造函数获取资源，通过析构函数释放资源。‌\n智能指针的主要目的是解决原始指针使用中的内存管理问题，‌如内存泄漏和悬挂指针等。‌智能指针的实现通常涉及到引用计数的机制，‌当智能指针指向的对象不再被使用时，‌引用计数会减少，‌当引用计数达到零时，‌智能指针会自动释放所指向的对象，‌从而避免内存泄漏。‌此外，‌智能指针还可以提供对对象生命周期的更精细控制，‌例如在需要时延迟对象的销毁或共享对象的所有权等 头文件是\nshared_ptr 使用引用计数的方式来管理内存。多个shared_ptr可以指向同一个对象，当最后一个shared_ptr被销毁时，对象才会被释放。适用于多个对象需要共享同一个资源的场景，比如在多个函数之间传递一个对象，并且需要保证在所有使用该对象的地方都不再需要时才释放资源。\nunique_ptr 直接防止拷贝的方式解决智能指针的拷贝问题，简单而又粗暴，防止智能指针对象拷贝，保证资源不会被多次释放。 可以通过move函数转移给其他的unique_ptr， unique_ptr是独占式的智能指针，它保证在任何时刻只有一个unique_ptr指向一个对象，当unique_ptr被销毁时，它所指向的对象也会被自动释放。适用于需要独占资源的场景，比如在函数内部创建一个对象并返回给调用者时，可以使用unique_ptr来确保资源的正确释放。\nweak_ptr expired() 它是来判断观测的资源是否被释放 lock 获取管理所监测资源的share_ptr对象 reset 置零 其他减一 std::weak_ptr是一种弱引用的智能指针，它不会增加对象的引用计数，主要用于解决std::shared_ptr可能出现的循环引用问题。当需要观察一个由std::shared_ptr管理的对象，但又不想影响对象的生命周期时，可以使用std::weak_ptr。\n","date":"2023-09-15T17:34:23+08:00","image":"https://L-Y-D-0129.github.io/p/c-/21092500555TF2-0-lp_hu14551486516089585684.jpg","permalink":"https://L-Y-D-0129.github.io/p/c-/","title":"C++"},{"content":"TCP TCP连接 什么是TCP？ TCP是面向连接的、可靠的、基于字节流的传输协议。\n面向连接：一定是1对1 才能连接，不能像UDP协议可以一台主机同时向多个主机发送消息，也就是一对多是无法做到的 可靠的：无论网络链路中出现了什么样的变化，TCP都可以保证一个报文一定能够到达接收端。 字节流：就是可以说当在传输层发消息的时候，一个消息可能会被分割成多个tcp报文进行转发给网络层，我们不能认为一个tcp报文就是一个消息，所以tcp是面向字节流的 （由于是面向字节流 ，就有可能会出现粘包的问题。） 如何唯一确定TCP连接？ 通过四元组就是（源地址、源端口、目标地址、目标端口）\n源地址存在IP协议的头部中，作用是通过IP协议发送报文给对方主机\n端口号存在TCP的头部中，作用是通过TCP协议应该把报文给那个端口\n通过这四个组合可以确定唯一的TCP连接\nTCP 和 UDP 有什么区别？ 应用场景是什么？ 连接上的区别\ntcp 是面向连接的，传输数据之前要建立连接。\nudp是不需要连接，即刻传输数据\n服务对象\ntcp是一对一的两点服务\nudp是支持一对一，一对多，多对多的\n可靠性\ntcp是可靠性交付，数据可以没有差错，不丢失，不重复，按时到达。\nudp不是可靠的，不保证可靠交付数据。\n拥塞控制、流量控制\ntcp有流量控制和拥塞控制机制，保证数据的传输安全\nudp没有这些，即使网络非常拥堵，也不影响udp的传输效率\n首部开销\ntcp 的首部开销比较大 ，再首部没有选项字段时时20 字节，如果使用了，会变长。\nudp 的首部开销时固定的，比价小，只有8 字节\n传输方式\ntcp是字节流传输，没有边界（有可能导致粘包问题） ，单保证顺序和可靠\nudp是一个包一个包发送的，有边界，但是不可靠。\n分片不同\ntcp的数据大小再超多MSS大小，就会在传输层分片，目标主机收到会在传输层进行组装tcp数据包，如果中途丢失了，只需要传输丢失的部分即可。 MSS = MTU - IP （首部）- TCP（首部） udp的大小如果超过了MTU（1500字节）大小，就会再IP层分片，目标主机收到会再IP 层组装，再给传输层。\n为什么要进行三次握手，不是二次、四次？ 原因有 3 个\n3次握手可以防止历史连接的建立，导致初始化混乱（主要原因） 同步双方初始序列号 避免资源浪费\n防止旧连接的建立导致初始化混乱 我们假设一个情景就是当客户端第一次发起连接的时候，网络阻塞，这个时候客户端没有收到连接请求，客户端重启之后再次发出请求，这个时候旧的请求连接旧会比新的连接先到达，服务器进行回复，如果是两次握手在服务器接收到消息的时候，就已经建立了连接，这个时候服务器回复确认号以及序列号，但是客户端发现这不是我要接收到的序列号，就会发起RST报文，让服务器释放连接，造成了资源浪费，如果是三次握手就不会有这样的情况，因为不会再第一次握手就建立连接。\n同步双方的序列号 TCP协议的通信双方，都必须维护一个序列号，序列号是可靠传输的一个关键因素。 它的作用：接收方可以根据序列号取出重复的数据， 可以根据序号接收，可以表示发送出去的数据包那些被接收了，通过ACK报文中的序列号来知道。 二两次握手只能确认一方的序列号。 TCP 为什么每次建立连接的序列号都要求不一样呢？ 如果每次都一样，就大概率会遇到历史报文的序列号，恰好再对方的接收窗口内， 那么就回导致数据错乱，这样如果每次建立连接的序列号都不一样的化，就会很大程度上避免了这样的情况。\n但是初始化序列号和 序列号 并不是无线递增的，就会发生回绕的情况， 这就代表这不能完全根据序列号来判断新老数据，为了解决这个问题 ，TCP使用了时间戳， tcp_timestamps ， 他有两个好处，一个就是便于RTT【包的往返时间】的计算，另一个就是防止序列号回绕的问题。\n既然IP层会分片，为什么TCP层还需要MSS呢？ 如果将TCP的整个报文，交给IP层来进行分片，有一个隐患就是当一个IP分片丢失，整个报文的所有分片都要重新上传，因为IP层没有超时重传机制，当有一个分片丢失，接收方就无法再IP层组装一个完整的TCP报文，也就无法发送确认接收的ACK，发送方一直无法接收到接收方的ACK确认，那么发送端就会触发TCP超时重传机制，再次组装重新交给IP层进行发送。这样的效率是不高的，因为数据包当大于MSS就会进行分片，那么也一定小于MTU，也就不需要IP层进行分片了。\nTCP和UDP可以使用同一个端口么？ 多个TCP服务进程可以同时绑定同一个端口么？ 重启TCP服务进程时，为什么会出现“Address in use” 的报错信息？ 又该怎么避免面？ 客户端的端口可以重复使用吗？ 客户端TCP来凝结TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立连接么？ 可以的，再数据链路层，通过mac地址来寻找局域网中的主机，再网络层中，通过IP地址来寻找网络中相连的主机和路由器。 再传输层中，通过端口号进行寻址，来识别同意计算机中的不同应用程序。 传输层中的两个协议TCP 和 UDP 再内核中式两个完全独立的模块。再IP包头部的协议号字段就能知道是哪个协议，并把它们发给对应的模块进行处理，最后再根据端口号确定送给那个程序。\n初始序列号ISN是如何产生的？ 初始 ISN 时基于时钟的， 每4微秒 +1 ，转一圈要4.55 个小时 RFC793 提出了初始化学列号ISN随机生成算法 ： ISN = M + F（四元组）\nM 时一个计时器，每隔 4 微秒+1 F 是一个Hash 算法， 根据四元组生成一个随机值，保证Hash算法不能被外部轻易推出。\n而其，随机数是基于始终计时器进行递增的，随意基本不会出现相同的初始化序列号。\n第一次握手丢失会发生什么？ 客户端想和服务器建立TCP连接，会发送SYN 请求和一个初始化序列号， 如果第一个包丢失，倒置一直没收到服务器的SYN-ACK（第二次握手），就会触发【超时重传】 机制， 重传 SYN报文，而其重传的SYN的序列号都是一样的。 不同版本的操作系统有不同的超时重传机制， 有点是1 秒 ， 有的是 3 秒，具体时间是内核来控制的。\n在客户端没收到服务器的回应就会【超时重传】Linux 中有一个内核参数tcp_syn_retries来控制整个次数，\n这个参数可以自定义， 默认值是5 。\n一般的超时重传的时间是以2倍变化的，再第五次重传后再等待 32 秒，客户端再次发送请求，还是没有收到ACK确认，客户端就不会再发了，会断开TCP连接。 总耗时就是 1 +2 +4+8 +16 +32 = 63 大概1 分钟左右。\n第二次握手数据丢失会发生什么？ 客户端和服务器都会进行【超时重传】 因为客户端会认为自己没发过去，服务器也会觉得自己每发送过去。控制第二次握手的参数是 tcp_synack_retries 由内核决定。剩下的流程和i第一次是一样的。\n第三次握手对视会发生什么？ 当服务端超时重传2次 SYN-ACK报文后，由于 tcp_synack_retries 为2，已达到最大重传次数，于是再等待一段时间(时间为上一次超时时间的2倍)，如果还是没能收到客户端的第三次握手(ACK 报文)，那么服务端就会断开连接。\n因为第三次是客户端进行确认ACK报文， ACK报文不会重传！\n什么是SYN攻击？如何避免SYN攻击？ 就是攻击者再短时间内伪造不同的IP地址的SYN报文像服务器发送请求，服务器就会返回SYN+ACK，不会受到回应，久而久之就会导致服务器的半连接队列被占满，这样服务器不能为正常的用户服务。\n半连接队列（SYN队列）：就是当服务器收到SYN请求，将客户端的SYN请求加入到半连接队列中。 全连接队列（Accept队列）：是当服务器与客户端通过3次握手之后，就会创建一个对象这个队列中。 最后通过调用accpet() socket接口，从全连接队列中取出。\n不管是，全连接还是半连接队列，都有最大长度限制，超过限制，默认情况都会丢弃报文导致，无法与其他建立连接。SYN攻击就是主共半连接队列，当TCP半连接队列满了，就无法与客户端建立连接了。 避免SYN攻击的四种办法：\n调大netdev_max_backlog; 增大TCP半连接队列 开启tcp_syncookies;\n开启这个功能就是，当半连接队列满了之后，不丢弃报文，而是根据算法，计算除一个cookie值； 把这个值放在第二次握手的应答报文中，发送给客户端 当服务器接收到客户端的应答报文时，就会检查它的合法性，如果合法就会将对象放入Accept队列 最后再调用accpet() 接口 ， 从Accept队列中取出连接。 net.ipv4.tcp_syncookies参数有3 个值：\n0 就是关闭该功能\n1 就是仅当SYN半连接队列放不下时，再启用他\n2 就是无条件开启功能\n减少SYN+ACK重传次数 TCP 连接断开 这就是TCP断开连接的过程，以及双方的状态 这里要注意的一点就是只有主动断开连接，才有TIME_WAIT状态\n为什么需要四次挥手？ 因为是这样的，我们四次挥手的过程就是 ， 一方发出申请，发出申请的一方表示我想断开连接，我不会再发数据给你了，这个时候可以接收数据， 这个时候服务器回复一个确认，然后出现closed_wait 状态，这个时间，就是用来给服务器处理数据和发送消息的。等服务器数据处理完毕， 它才会发送FIN 报文来表示现在可以关闭连接，并且进入LAST_ACK状态，发起方收到来自服务器的FIN，返回ACK就会进入TIME_WAIT 状态。\nACK报文为什么不会重传？ ACK报文不消耗序列号 再TCP协议中，学列号用于表示发送的数据顺序，而ACK报文本身不携带数据，也不占序列号空间，所以不需要重传，可以通过后续发送方的响应进行判断是否ACK已经被成功接收。 避免重复确认的混乱 就是ACK也要进行重传，那么如果有网络波动也就可能会导致一种情况，例如发送方的数据包1，2，3 ，正常情况下接收方收到数据包1 发送ACK确认序号为2 的报文。但如果这个ACK报文被重传了好多次，发送方会认为接收方一直在等待数据包 2，因为它连续收到了确认序号为 2 的 ACK，这就暗示着数据包 2 及后续的数据包可能没有被正确接收。，没有接收到数据2，3 从而进行不必要的传输。 第一次挥手丢失会发生什么？ 如果第一次挥手就发生数据丢失，客户端会触发【超时重传】机制，一般Linux中默认是 7 次不同的版本和内核版本可能有所不同， 时间也是2的倍数进行翻倍的，过了这个时间，客户端就会断开连接。\n第二次挥手丢失会发生什么？ 首先发送断开请求的一方会进入FIN_WAIT_1状态，然后接收方的第二次挥手对视会导致，发送方无法确认他是否发送，它就会触发【超时重传】再进行发送FIN请求。接收方看到对方有发送了FIN请求就知道自己确认应答的消息没有发出，那么就会继续发送。但是如果还是丢失会根据一个限制超时重传的机制的数量来决定发送方会发出几次FIN请求。如果抵达了最大重传次数那么就会断开连接。 但是注意如果使用shutdown() 来进行关闭的话， 那么就要看shutdown()关闭的方式\nSHUT_RD：关闭接收通道，不能再从这个套接字接收数据 SHUT_WR：关闭发送通道，不能通过这个套接字发送数据 SHUT_RDWR: 同时关闭接收和发送通道\n这里要注意的就是，如果shutdown只关闭读取的通道，而不关闭发送的通道，内核是不会发送FIN报文的，因为内核发送FIN报文的时候要看你是否有发送数据的能力，如果你有能力他是不会发送FIN报文的。\nshutdown() 和 close() 的区别 ： 就是close() 有可能会导致数据的丢失，而shutdown() 可以更加灵活的控制关闭的过程，给数据缓冲的机会。 什么情况下close() 会导致数据丢失 以及为什么 shutdown（） 可以给缓冲区机会？\n一个套接字可以执行一次shutdown() , 但只能被close() 多次 第三次挥手丢失会发生什么？ 流程是这样的，当服务器接收到客户端的FIN 报文之后，内核会自动回复ACK报文，同时处于CLOSE_WAIT状态，故名思义，他就是为了等待程序自行调度close() 函数。\n调用这个close() 函数， 内核就会发送FIN报文，同时进入LAST_ACK状态 也就是等待最后确认应答状态。\n如果迟迟没有接收到客户端发送的确认应答，那么就会触发【超时重发】机制，同样这个重发次数仍然是通过tcp_orphan_retries 来控制的。\n再进行第二次挥手的时候客户端就会进入到FIN_WAIT_2 状态默认是 60 s 如果一直没有接收到服务器的FIN报文客户端就会关闭。\n第四次挥手丢失会发生什么？ 当客户端收到了服务器的第三次挥手的FIN报文客户端就会进入TIME_WAIT 状态 持续 2MSL ，此时服务器处于LAST_ACK 状态也就是等待最后确认的状态，但是第四次挥手丢失，就触发了服务器的【超时重传】机制，这样服务器就会再【超时重传】机制的限制内进行重发每一次重发都会导致，客户端重置2MSL定时器，直到服务器不在抵达的【超时重传】的限制后，客户端再等2MSL就关闭了，服务器会再次等待上次重传的时间的2倍 反正应该小于一分钟所以服务器会先行关闭。\n为什么TIM_WIAIT 等待时间是2MSL？ MSL 是报文的最大生存时间， 它是任何报文再网络上存在的最长时间， 超过这个时间报文就会被丢弃。 TCP 协议是基于 IP协议的 ， IP头中有一个字段是 TTL，是IP数据报可以经过的最大路由器数，每经过一个处理它的路由器他就会减 1 ， 当TTL=0 这个数据包将被丢弃，同时发送ICMP（互联网控制报文协议）报文通知源主机。\nMSL 和 TTL的区别：MSL的单位是时间， TTL的单位是经过路由器的跳数，所以MSL应该大于TTL消耗到0 的时间，以确保报文已经自然消亡。\nTTL一般时间为64 ，Linux MSL的时间为30 秒 ，意味着Linux认为数据报文经过 64个路由器的时间不会超过 30 秒，如果超过了 ， 就认为报文已经消失再网络中了。\n至于TIME_WAIT 的时间是 2MSL = 60 s，是比较合理的，因为再网络中我发送给你，你处理后又会发送给我，这样一来一会2MSL刚好够了。\n为什么需要TIME_WAIT 状态？ 主动发起关闭的一方才会，才会有TIME_WAIT 状态\n需要TIME_WAIT 状态有连个原因：\n为了保证被动关闭的一方，可以正确关闭 这个就是如果最后一次ACK确认丢失了，那么服务端就会触发【超时重传】，假设客户端没有TIME_WAIT 状态那么，进行第四次挥手之后就直接进入CLOSE 状态这个时候服务端如果向再向我发送FIN请求客户端就会放回RST 这样就导致服务器异常终止。这样的行为是不优雅的。 防止历史连接中的数据，被后面相同的四元组的连接错误接收 错误接收的情况，是seq 和 isn 都有是回绕的，这就意味着没有办法通过序列号来判断新老数据。 如上图： 服务器关闭连接之前，发送的seq = 301 被网络延迟了 接着，服务器以相同的四元组重新打开了连接， 这个时候之前被延迟的数据包恰好在客户端的接收窗口的范围内，那么就导致了数据错乱的问题。 所以TCP设计了TIME_WAIT 状态，以用来保证让两个方向的数据包都被丢弃，是的原来的数据包都自然消失，确保出现数据包一定是新的连接产生。\nTCP重传机制、滑动窗口、流量控制、拥塞控制 TCP数据包丢的情况，会用重传机制解决：\n超时重传 快速重传 SACK D-ACK 超时重传 再发送数据的时，设定一个定时器，当超过指定的时间后，没有搜到对方的ACK确认应答报文，就会重发数据。 有两种情况会导致超时重传：\n数据包丢失 确认应答丢失 介绍两个词 一个是RTT ，一个是 RTO RTT 就是一个包的往返时间差值 RTO 是由系列根据RTT 的公式进行计算的 因为超时时间限制设置的太短和太长都不好，太短会倒是不必要的重传，是网络的负荷增大。太长呢又降低效率。 根据分析RTO因该比RTT略大一些就可以。\n超时重传就一个问题：就是超时周期过程相对较长，次数是由内核里面的参数来决定的，等待时间都是 2 倍的。 快速重传 就是当客户端向服务器发送了数据，发送了5个包 ，有1，2，3，4，5 其中第二个丢失了， 但是还没有到超时的时间 ，这个时候服务器就会回复三个序列号为2 的ACK报文，这样服务器就会返回三个序列号为2 的ACK确认，在定时器之前，进行重传。\n但是有一个问题就是，如果他有两个包丢失了他无法直接重传，两个因为他触发快速重传触发的事第一个丢失的包的ACK2，他就会传一个包，或者传多个 ， 一个会导致效率慢，多个有重复，增加传输压力。\nSACK方法 SACK就是选择重传： 就是当有数据丢失的时候可以通过TCP头部中加一个SACK的东西，它可以将已收到信息发送给发送方，这样发送方就可以只发送丢失的数据了。 例如：使用条件：要双发都支持SACK，在Linux中 ， 可以通过 net.ipv4.tcp_sack 参数打开这个功能。 Duplicate SACK Duplicate SACK 又叫D-SACK D-SACK的好处：\n可以让【发送方】知道，是发出的包丢了，还是接收方回应的ACK包丢了 可以知道是不是【发送方】的数据包被网络延迟了 可以知道网络中是不是把【发送方】的数据包给复制了\n在Linux中可以通过net.ipv4.tcp_dsack 开启/关闭这个功能。 滑动窗口 滑动窗口的概念的引入，就是提高了效率，就好比你说一句我说一句， 你和我说完话，我有点事没回复你，你就不说话了么？ 对吧不现实，而且效率太慢了。\n这就有了窗口这个概念，即使往返时间长，它也不会降低网络通信的效率。窗口的实现是操作系统开辟的一个缓存空间，发送方发送数据后，要将数据保存在缓存区中。如果定期到达并受到确认应答，此时数据就可以从缓存区清除了。 有了窗口，就有窗口大小，在窗口大小就是在范围内无需等待应答，可以继续发数据的最大值 窗口的大小由接收方决定：TCP头部有一个Window 字段， 就是窗口的大小，通过这个字段接收方，将字节还有多少缓存区可以接收数据告诉对方，于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。\n流量控制 其实就是通过控制窗口的大小来，控制流量，但是有可能导致窗口关闭，窗口关闭就又潜在的危险，就是当窗口关闭了，当接收方处理完数据，窗口增大的时候，想在发送ACK确认的话，如果这次ACK确认丢失了，就有可能导致，一种类似于死锁的现象，就是发送方等着接收方，增加窗口的大小，接收方等着发送方发送数据。\n如何解决窗口关闭，导致的潜在死锁的问题呢？ 使用名为窗口探测的机制，来解决这个死锁的情况， 就是当窗口关闭的时候， 发送方就会启动持续定时器，哪怕是接收方发送消息已经解决完了，窗口已经增大了，也可以等这个持续计时器超时后，发送方发送窗口探针报文，来解决死锁的局面。\n如果还没有增大窗口，就重启持续定时器。 拥塞控制 因为当，在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大。\n拥塞窗口cwnd 是 min (swnd , rwnd) 拥塞窗口cwnd 变化的规律 只要网路中没有出现拥塞，cwnd就会增大 相反网络中出现了拥塞，cwnd就会减少\n只要【发送方】没有按时间，接收到ACK确认应答，也就是发生的【超时重传】， 就会被认为是网络拥塞。 拥塞控制主要是四个算法： 慢启动 拥塞避免 拥塞发生 快速恢复 慢启动：当发送方每收到一个ACK ， 拥塞窗口 cwnd 的大小就会加1 。\n慢启动算法，发包的个数是以指数增长的，慢启动门限，就是 ssthresh (slow start threshold) 状态变量。 当cwnd \u0026lt; ssthresh 时， 使用慢启动算法 当cwnd \u0026gt;= ssthresh 时，就会使用拥塞避免算法 拥塞避免算法：就是如果，当cwnd \u0026gt;= ssthresh 的时候 发包就不在是指数上涨的，变成了线性上涨，减小网络拥塞的概率，但是还是上涨趋势，网络慢慢进入了拥塞的状况了，于是就可能出现丢包现象，这时候就需要对丢失的数据进行重传，当触发了【重传机制】，也就是进入了【拥塞发生算法】\n拥塞发生 重传机制是会【拥塞发生算法】是不同的\n超时重传，调用的【拥塞发生算法】就会将ssthresh = cwnd /2 ， cwnd =1 ，重新开始【慢启动算法】，这就相当于大幅度降低了传输的数量，可能会导致卡顿。\n在Linux 中 使用 ss -nli 命令来查看 每个TCP 连接的cwnd的初始化的值。\n快速重传，就是比较好的方式，当发生快速重传的时候，TCP认为这种情况不严重，因为大部分没有丢失，只丢失了一小部分，所以酌情处理，cwnd = cwnd/2 , ssthresh = cwnd。 进入快速恢复算法。\n快速恢复 在快速恢复的过程中，首先 ssthresh= cwnd/2，然后 cwnd=ssthresh+3，表示网络可能出现了阻塞，所以需要减小 cwnd 以避免，加3代表快速重传时已经确认接收到了3个重复的数据包;\n随后继续重传丢失的数据包，如果再收到重复的 ACK，那么 cwnd 增加 1。加1代表每个收到的重复的 ACK 包，都已经离开了网络。这个过程的目的是尽快将丢失的数据包发给目标。\n如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，恢复过程结束。\n首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。\n其次，过程2(cwnd逐渐加1)的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题(三次相同的 ACK 导致的快速重传)，所以这一过程中 cwnd 反而是逐渐增大的。\nTCP 一些经典的问题 如何理解TCP是面向字节流的协议？ 首先TCP是面向字节流， UDP是面向报文，因为操作系统对TCP和UDP协议的发送方的机制不同。\n对于UDP就是当我们组装好UDP头部的时候，就会将报文交给网络层去处理，而操作系统不会对UDP进行拆分，所以发出去的UDP是一个完整的用户消息，每一个报文就是消息的边界，对于多个UDP操作系统是将UDP加入到队列中，当用户调用recvfrom() 的时候就从队列中取一个数据， 从内核拷贝给用户缓冲区。\n对于TCP就是，操作系统会对TCP进行拆分，可能将一个TCP报文拆分成多个，在我们发送一条数据的时候，数据可能并没有被发送，只是从应用程序拷贝到内核中协议栈中，至于什么时候发送，要看发送窗口的大小、拥塞窗口以及当前发送缓冲区的大小。我们不能认为一个用户消息，就是一个TCP报文，所以说TCP是面向字节流的。\n正式因为面向字节流，就容易导致粘包问题，解决粘包问题的方法：\n固定长度 \u0026ndash; 不现实 设置特殊字符用来充当边界 \u0026ndash; 但是消息中原本既有了这个字符就麻烦了 自定义消息结构 \u0026mdash; 还是比较灵活现实的 什么是PAWS机制？ 当tcp_timestamps 选项开启的时候，PAWS机制就会自动开启，它的作用是防止，TCP包中的序列号放生回绕。\nPAWS就是为了避免这个问题的而产生的，在开启tcp_timesamps 的选项的时候， 一台机器发送所有的TCP包都会带上发送时的时间戳， PAWS要求双方一起维护最近收到数据包的时间戳， 没收到一个数据包就会读取数据包中的时间戳跟Recent TSval 的值坐比较， 如果发现数据包中的时间戳不是递增的，就代表这个数据包是过期的， 应该被丢弃；\n已经建立TCP连接，再次收到SYN，会发生什么情况？ 在这样的情况例如：客户端和服务器已经建立了连接，后来客户端宕机了，客户端向服务器再次发送SYN请求， 这个时候服务器收到了客户端的SYN报文，但是服务器不知道客户端发生了宕机的情况，那么服务器就会回复一个，携带正确序列号和确认号的ACK报文，这个ACK称为 Challenge ACK 。\n接着客户端收到这个CHallenge ACK的报文，发现并不是自己所期望的第二次握手，那么就会回复RST，服务器收到之后就断开了连接。\n如何关闭一个TCP连接？ 可以直接杀死进程 是的，这个是最粗暴的方式，杀掉客户端进程和服务端进程影响的范围会有所不同\n在客户端杀掉进程的话，就会发送 FIN 报文，来断开这个客户端进程与服务端建立的所有 TCP 连接这种方式影响范围只有这个客户端进程所建立的连接，而其他客户端或进程不会受影响。\n而在服务端杀掉进程影响就大了，此时所有的 TCP 连接都会被关闭，服务端无法继续提供访问服务。\n很显然，直接杀死进程是不可取的， 那么我们因该使用什么方式来杀死进程呢？\n在Linux 中有一个交killcx的工具就是可以平滑的关闭TCP连接，他的实现方式就是，通过这个killcx 工具伪造相同的四元组，代替客户端向服务器器发送SYN 请求。也就是利用了已经建立连接的TCP，再次发送SYN请求，这个时候服务器就会回复 Challenge ACK 。\n骗取服务器回复Challenge ACK 的序列号，从中得到服务器的确认号， 伪造RST来断开连接。 骗取服务器回复Challenge ACK 的序列号，从中得到序列号，伪造RST来断开连接。\n处理killcx 工具可以做到关闭TCP，tcpkill也可以做到，但是tcpkill工具是属于被动获取序列号的，它获取序列号的方式是，在TCP 通信的时候，获取正确的序列号， 从而发送RST报文关闭。这就代表tcpkill非常不适合关闭不活跃的TCP连接。\n四次挥手中收到乱序的FIN会如何处理？ 当收到乱序的FIN ， 会将这个乱序的数据包放入【乱序队列】中，当数据到达之后，再去判断队列中是否有FIN报文，有就会调用tcp_fin() 使状态有FIN_WAIT2 \u0026mdash;》TIME_WAIT 状态 所以说当不会立刻进入TIME_WAIT 状态。\n在TIME_WAIT状态下的TCP连接，在收到SYN报文会发生什么？ 首先是这样的要看是否合法？ 如何判断合法性呢？就是通过序列号和时间戳（开启timesample）时间戳机制后，如果双方都开启了时间戳报文：\n判断收到的客户端SYN的【序列号】是否比上一次【服务器】期望收到的下一个序列号要大，并且SYN的【时间戳】也要比【服务器】最后一次收到的报文时间戳要大。 相反有一个不满足就不是合法的SYN 如果没有开启时间戳选项，那么单独通过判断序列号是否比上一次大 ， true 就 合法 false 就不合法。\n如果使合法的SYN， 就进行进行三次握手的过程， 如果是不合法的那么就返回RST报文断开连接。\n当我们处于TIME_WAIT状态的时候，收到RST 会断开连接么？\n如果net.ipv4.tcp_rfc1337 参数为0 ， 则会提前结束TIME_WAIT 状态，释放连接。 如果net.ipv4.tcp_rfc1337 参数为1 ， 则会丢弃RST报文。\nTCP的保活机制 定义一个时间段，在这个时间段里面，如果没有任何关联的活动，TCP的保活机制就会开始作用，每个一个时间间隔，机会发送一个探测报文，该报文的数据非常少，如果连续几个探测报文都没有，得到回应，则就认为则这个TCP连接死亡了，系统内核将错误信息通知给上层应用程序。这个是可以修改的\nnet.ipv4.tcp_keepalive_time= 7200; // 保活时间为7200秒 ， 也就是在2小时内没有任何相关活动，就会开启保活机制。\nnet.ipv4.tcp_keepalive_intvl= 75; //每次检验的时间间隔是75 秒\nnet.ipv4.tcp_keepalive_probes= 9; //表示检测9次没有响应，认为对方是不可以到达，从而中断本次连接\n客户端在拔掉网线之后TCP连接是否发生变化？ 客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输\n有数据传输的情况:\n在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生\n在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。至此，双方的 TCP 连接都断开了\n没有数据传输的情况: 如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在 如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCPkeepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在\n服务器没有listen，客户端发起连接会发生什么？ 当服务器只绑定了IP地址和端口号，而没有调用listen 的话， 然后客户端对服务器发起建立连接，服务器会返回RST报文，来解除连接\nLinux内核处理收到TCP报文的入口函数是 tcp_v4_rcv ，在收到报文之后，会调用 _inet_lookup_skb函数查找TCP报文所属socket 。然后会查找监听套接字，根据目的地址和端口算出哈希值，然后再哈希表中找到对应监听改端口socket。没有找到那么就会直接返回RST报文，来断开连接。\n没有accept， 能建立TCP连接么？ 可以建立，因为三次握手的过程是不需要accept()的参与也能够完成的，其实accpet（）的作用就是从全连接队列里面将sock取出来，而其还是再握手之后才会调用accept() 。\n全连接队列：底层是一个链表， 因为里面存储的是已经建立连接的一些已完成三次握手的连接信息，通过调用accept()，函数来取出进行进一步的处理，从而创建一个真正用于数据传输的 socket 。因为这样的特性所以只要从头取就行，这个过程就是O(1) 的 。 半连接队列：底层是一个哈希表，因为再队列中储存的是一些未完成三次握手，建立连接的信息，当三次握手完成我们就要将相应的IP端口的连接取出，所以我们要使用查询效率快的那就是哈希表，时间复杂度就是O（1）。 全连接队列满了会怎么样？ 分为两种情况：\ntcp_abort_on_overflow = 1 会直接向客户端发送RST报文 。 tcp_abort_on_overflow = 0 的时候会将最后一次客户端发送的ACK丢弃。 TCP四次挥手，可以变成三次么？ 在一定情况下使可以的，本身这个四次挥手再第二次挥手后 ， 如果没有数据是可以将三次挥手变成四次挥手的 ，但是这建立再没有数据的前提下。如果四次挥手就变成三次的话，如果有数据要发送就不好处理了。\n什么情况下会发生三次挥手？ 当被动关闭的一方没有数据要发送并且【开启了TCP 延迟确认机制】 ， 那么第二次和第三次挥手就会关闭。这个延迟确认机制是默认打开的。\n什么是确认延迟机制：\n当有响应的数据要发送的时候， ACK会随着响应数据一起立刻发送给对方。 当没有响应数据要发送时，ACK将会延迟一段时间，以等待是否有由响应的数据可以一起发送 如果在延迟等待发送ACK期间，对方的第二个数据报文又到达了，那么就会立刻发送ACK 优雅关闭（shutdown） 和 暴力关闭（close） close() ， 同时关闭socket的发送和读取方向， 也就是socket 不在有发送和读取的能力，这个时候内核就会像对方发送FIN报文 ，进行四次挥手， 但是如果使多进程/线程的情况向，共享一个socket，这样你 调用了close() 只是将 socket的引用计数-1 ， 并不会导致socket 不可用， 内核也就不会发送FIN 报文，这样不影响其他进程的读写操作，知道引用计数变为0 ，才发送FIN报文。 shutdown() ，可以指定socket以那种发生进行关闭，如果使关闭发送方向，那么socket就没有了发送能力，但是还有接收数据的能力，如果使多线程/进程，共享一个socket，shutdown也不会管引用计数，直接就导致socket不可以用了 ，然后发送FIN报文，别的进程也用不了。 SHUT_RD：关闭接收通道，不能再从这个套接字接收数据 SHUT_WR：关闭发送通道，不能通过这个套接字发送数据 SHUT_RDWR: 同时关闭接收和发送通道\n调用close() ，这个时候同时关闭了发送和读写能力，这个时候也会完成四次会后只不过都是由操作系统来帮助我们完成四次挥手的过程，但是这个时候如果服务器再第二次挥手和第三次挥手的过程中发送数据，这部分数据就丢失了。因为关闭了接收和发送通道。\n调用shutdown() ，需要注意的是虽然有多种方式去关闭通道但是如果保留了【发送通道】代表这个socket还拥有发送的能力，那么内核就不会发送FIN报文。\n","date":"2023-01-17T00:00:00Z","image":"https://L-Y-D-0129.github.io/p/network/14d5f80f66984e48a8701cf2b360728d_hu44059843745792567.jpeg","permalink":"https://L-Y-D-0129.github.io/p/network/","title":"Network"},{"content":"","date":"2022-12-17T00:00:00Z","image":"https://L-Y-D-0129.github.io/p/linux/210925002600MB-0-lp_hu9809017230367901245.jpg","permalink":"https://L-Y-D-0129.github.io/p/linux/","title":"Linux"},{"content":"","date":"2022-10-01T00:00:00Z","image":"https://L-Y-D-0129.github.io/p/mysql/5d199bc887724f9aa80e557d03cf7e30_hu5007558375543281075.webp","permalink":"https://L-Y-D-0129.github.io/p/mysql/","title":"Mysql"}]