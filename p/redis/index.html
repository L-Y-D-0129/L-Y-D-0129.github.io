<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="前言 Hello，各位好，我是刘煜鼎！\n这篇文档集合了一些Redis知识\n主要为数据结构、持久化、集群、缓存等相关知识。\nRedis常见数据类型和应用场景 Redis中常见的数据类型有五种：String（字符串），Hash（哈希），List（列表），Set（集合），Zset（有序集合）。\n">
<title>Redis</title>

<link rel='canonical' href='https://L-Y-D-0129.github.io/p/redis/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="Redis">
<meta property='og:description' content="前言 Hello，各位好，我是刘煜鼎！\n这篇文档集合了一些Redis知识\n主要为数据结构、持久化、集群、缓存等相关知识。\nRedis常见数据类型和应用场景 Redis中常见的数据类型有五种：String（字符串），Hash（哈希），List（列表），Set（集合），Zset（有序集合）。\n">
<meta property='og:url' content='https://L-Y-D-0129.github.io/p/redis/'>
<meta property='og:site_name' content='刘煜鼎de学习日记'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-01-21T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2024-01-21T00:00:00&#43;00:00'/><meta property='og:image' content='https://L-Y-D-0129.github.io/p/redis/2109242356423Y8-0-lp.jpg' />
<meta name="twitter:title" content="Redis">
<meta name="twitter:description" content="前言 Hello，各位好，我是刘煜鼎！\n这篇文档集合了一些Redis知识\n主要为数据结构、持久化、集群、缓存等相关知识。\nRedis常见数据类型和应用场景 Redis中常见的数据类型有五种：String（字符串），Hash（哈希），List（列表），Set（集合），Zset（有序集合）。\n"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://L-Y-D-0129.github.io/p/redis/2109242356423Y8-0-lp.jpg' />
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu11432763322269111238.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🤔</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">刘煜鼎de学习日记</a></h1>
            <h2 class="site-description">欢迎来到我的网站</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/L-Y-D-0129'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#string">String</a>
      <ol>
        <li><a href="#介绍">介绍</a></li>
        <li><a href="#内部实现">内部实现</a></li>
        <li><a href="#常用操作">常用操作</a></li>
        <li><a href="#应用场景">应用场景</a>
          <ol>
            <li><a href="#缓存对象">缓存对象</a></li>
            <li><a href="#常规计数">常规计数</a></li>
            <li><a href="#分布式锁">分布式锁</a></li>
            <li><a href="#共享session信息">共享session信息</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#list">List</a>
      <ol>
        <li><a href="#介绍-1">介绍</a></li>
        <li><a href="#内部实现-1">内部实现</a></li>
        <li><a href="#常用操作-1">常用操作</a></li>
        <li><a href="#应用场景-1">应用场景</a>
          <ol>
            <li><a href="#消息队列">消息队列</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#hash">Hash</a>
      <ol>
        <li><a href="#介绍-2">介绍</a></li>
        <li><a href="#内部实现-2">内部实现</a></li>
        <li><a href="#常用操作-2">常用操作</a></li>
        <li><a href="#应用场景-2">应用场景</a>
          <ol>
            <li><a href="#缓存对象-1">缓存对象</a></li>
            <li><a href="#购物车">购物车</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#set">Set</a>
      <ol>
        <li><a href="#介绍-3">介绍</a></li>
        <li><a href="#内部实现-3">内部实现</a></li>
        <li><a href="#常用操作-3">常用操作</a></li>
        <li><a href="#应用场景-3">应用场景</a>
          <ol>
            <li><a href="#点赞">点赞</a></li>
            <li><a href="#共同关注">共同关注</a></li>
            <li><a href="#抽奖活动">抽奖活动</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#zset">Zset</a>
      <ol>
        <li><a href="#介绍-4">介绍</a></li>
        <li><a href="#内部实现-4">内部实现</a></li>
        <li><a href="#常用操作-4">常用操作</a></li>
        <li><a href="#应用场景-4">应用场景</a>
          <ol>
            <li><a href="#排行榜">排行榜</a></li>
            <li><a href="#电话姓名排序">电话、姓名排序</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#键值对数据库是怎么实现的">键值对数据库是怎么实现的？</a></li>
    <li><a href="#sds">SDS</a>
      <ol>
        <li><a href="#sds结构设计">SDS结构设计</a></li>
      </ol>
    </li>
    <li><a href="#链表">链表</a>
      <ol>
        <li><a href="#链表节点结构设计">链表节点结构设计</a></li>
        <li><a href="#链表结构设计">链表结构设计</a></li>
        <li><a href="#链表的优势与缺陷">链表的优势与缺陷</a></li>
      </ol>
    </li>
    <li><a href="#压缩列表">压缩列表</a>
      <ol>
        <li><a href="#压缩列表结构设计">压缩列表结构设计</a></li>
        <li><a href="#压缩列表的缺陷">压缩列表的缺陷</a>
          <ol>
            <li><a href="#连锁更新问题">连锁更新问题</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#哈希表">哈希表</a>
      <ol>
        <li><a href="#哈希表结构设计">哈希表结构设计</a></li>
        <li><a href="#哈希冲突">哈希冲突</a>
          <ol>
            <li><a href="#什么是哈希冲突呢">什么是哈希冲突呢</a></li>
          </ol>
        </li>
        <li><a href="#链式哈希">链式哈希</a>
          <ol>
            <li><a href="#链式哈希怎么实现的">链式哈希怎么实现的？</a></li>
          </ol>
        </li>
        <li><a href="#rehash">rehash</a></li>
        <li><a href="#渐进式rehash">渐进式rehash</a></li>
      </ol>
    </li>
    <li><a href="#整数集合">整数集合</a>
      <ol>
        <li><a href="#整数集合结构设计">整数集合结构设计</a></li>
        <li><a href="#整数集合的升级操作">整数集合的升级操作</a>
          <ol>
            <li><a href="#整数集合升级有什么好处呢">整数集合升级有什么好处呢？</a></li>
            <li><a href="#整数集合支持降级操作吗">整数集合支持降级操作吗？</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#跳表">跳表</a>
      <ol>
        <li><a href="#跳表结构设计">跳表结构设计</a></li>
        <li><a href="#跳表节点查询过程">跳表节点查询过程</a></li>
        <li><a href="#跳表节点层数设置">跳表节点层数设置</a>
          <ol>
            <li><a href="#那怎样才能维持相邻两层的节点数量的比例为-2--1-呢">那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？</a></li>
          </ol>
        </li>
        <li><a href="#为什么用跳表而不用平衡树">为什么用跳表而不用平衡树？</a></li>
      </ol>
    </li>
    <li><a href="#quicklist">quicklist</a></li>
    <li><a href="#listpack">listpack</a></li>
  </ol>

  <ol>
    <li><a href="#aof日志">AOF日志</a></li>
    <li><a href="#三种写回策略">三种写回策略</a></li>
    <li><a href="#aof重写机制">AOF重写机制</a></li>
    <li><a href="#aof后台重写">AOF后台重写</a></li>
    <li><a href="#总结-1">总结</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/redis/">
                <img src="/p/redis/2109242356423Y8-0-lp_hu11024188421021465833.jpg"
                        srcset="/p/redis/2109242356423Y8-0-lp_hu11024188421021465833.jpg 800w, /p/redis/2109242356423Y8-0-lp_hu15644524752345769741.jpg 1600w"
                        width="800" 
                        height="449" 
                        loading="lazy"
                        alt="Featured image of post Redis" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" >
                数据结构
            </a>
        
            <a href="/categories/%E7%BC%93%E5%AD%98/" >
                缓存
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/redis/">Redis</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-01-21</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="前言">前言
</h1><blockquote>
<p>Hello，各位好，我是刘煜鼎！</p>
<p>这篇文档集合了一些Redis知识</p>
</blockquote>
<p>主要为数据结构、持久化、集群、缓存等相关知识。</p>
<h1 id="redis常见数据类型和应用场景">Redis常见数据类型和应用场景
</h1><p>Redis中常见的数据类型有五种：<strong>String（字符串），Hash（哈希），List（列表），Set（集合），Zset（有序集合）。</strong></p>
<p>随着Redis版本的更新，后面又支持了四种数据类型：<strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。</strong></p>
<h2 id="string">String
</h2><h3 id="介绍">介绍
</h3><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串，也可以是数字(整数或浮点数)，value 最多可以容纳的数据长度是512M。</p>
<h3 id="内部实现">内部实现
</h3><p>String类型的底层的数据结构实现主要是int和SDS（简单动态字符串）。</p>
<p>SDS相比于C的原生字符串：</p>
<ul>
<li>**SDS 不仅可以保存文本数据，还可以保存二进制数据。**因为SDS使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[]数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li>
<li>**SDS 获取字符串长度的时间复杂度是 O(1)。**因为C语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n);而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。</li>
<li>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li>
</ul>
<p><strong>字符串的内部编码（encoding）有三种：int、raw和embstr（raw和embstr为SDS（简单动态字符串））。</strong></p>
<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用 long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面(将 void*转换成 long)，并将字符串对象的编码设置为int 。</p>
<p>如果字符串对象保存的是一个字符串则有两种情况：</p>
<ol>
<li>字符串长度小于等于32字节（redis2.+版本）
字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串，并将对象的编码设置为 embstr，embstr 编码是专门用于保存短字符串的一种优化编码方式。</li>
<li>字符串长度大于32字节（redis2.+版本）
那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串，并将对象的编码设置为 raw。</li>
</ol>
<p>可以看到 embstr 和 raw 编码都会使用 SDS 来保存值，但<strong>不同之处在于</strong> embstr 会通过<strong>一次内存分配</strong>函数来分配一块连续的内存空间来保存 redisobiect 和 SDS ，而 raw 编码会通过调用<strong>两次内存分配</strong>函数来分别分配两块空间来保存 redisobject 和 SDS 。Redis这样做会有很多好处:</p>
<ul>
<li>embstr 编码将创建字符串对象所需的内存分配次数从 raw编码的两次降低为一次;</li>
<li>释放 embstr 编码的字符串对象同样只需要调用一次内存释放函数;</li>
<li>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。</li>
</ul>
<p>但是 embstr 也有缺点的:</p>
<ul>
<li>如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以<strong>embstr编码的字符串对象实际上是只读的</strong>，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令(例如append)时，程序会先将<strong>对象的编码从embstr转换成raw</strong>，然后再执行修改命令。</li>
</ul>
<h3 id="常用操作">常用操作
</h3><ul>
<li>set：设置字符串</li>
<li>get：读取字符串</li>
<li>incr：自增（1）</li>
<li>decr：自减（1）</li>
<li>exists：判断某个key是否存在</li>
<li>strlen：返回字符串长度</li>
<li>del：删除key</li>
<li>expire：设置过期时间</li>
<li>ttl：查看剩余过期时间</li>
<li>set nx：不存在就插入（成功返回1，失败返回0）</li>
<li>mset：批量设置字符串</li>
<li>mget：批量读取字符串</li>
</ul>
<h3 id="应用场景">应用场景
</h3><h4 id="缓存对象">缓存对象
</h4><p>使用 String 来缓存对象有两种方式:</p>
<ul>
<li>
<p>直接缓存整个对象的JSON，命令例子:SET user:1&rsquo;{&ldquo;name&rdquo;:&ldquo;隔壁老王&rdquo;，“age”:38}'</p>
</li>
<li>
<p>采用将 key 进行分离为 user:ID:属性，采用 MSET存储，用 MGET获取各属性值，</p>
<p>命令例子:</p>
<p>MSET  user:1:name &ldquo;隔壁老王头&rdquo; user:1:age 38</p>
<p>​			 user:2:name &ldquo;楼下老吴头&rdquo; user:2:age 40</p>
</li>
</ul>
<h4 id="常规计数">常规计数
</h4><p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p>
<h4 id="分布式锁">分布式锁
</h4><p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁</p>
<ul>
<li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功;</li>
<li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li>
</ul>
<h4 id="共享session信息">共享session信息
</h4><p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p>
<p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题，问题在于分布式系统每次会把请求随机分配到不同的服务器。</p>
<p>因此，我们需要借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p>
<h2 id="list">List
</h2><h3 id="介绍-1">介绍
</h3><p>List列表是最简单的字符串列表，按照插入顺序排序，可以从头部或尾部向List列表添加元素。</p>
<p>列表的最大长度为2^32 - 1，即每个列表支持超过40亿个元素。</p>
<h3 id="内部实现-1">内部实现
</h3><p>类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的:</p>
<ul>
<li>如果列表的元素个数小于 512个，列表每个元素的值都小于 64 字节，Redis 会使用<strong>压缩列表</strong>作为List 类型的底层数据结构;</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构;</li>
<li>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist （二者结合）实现了，替代了双向链表和压缩列表。</strong></li>
</ul>
<h3 id="常用操作-1">常用操作
</h3><ul>
<li>lpush：在list左侧插入一个新元素</li>
<li>rpush：在list右侧插入一个新元素</li>
<li>lrange：从list中指定一个范围来提取元素</li>
<li>lpop：移除并返回列表头元素</li>
<li>rpop：移除并返回列表尾元素</li>
</ul>
<h3 id="应用场景-1">应用场景
</h3><h4 id="消息队列">消息队列
</h4><p>消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p>
<p>Redis 的 List 和 Stream 两种数据类型，就可以满足消息队列的这三个需求。</p>
<ol>
<li>
<p>如何满足消息保序需求？</p>
<p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p>
<p>List 可以使用 LPUSH+RPOP(或者反过来，RPUSH+LPOP)命令实现消息队列。</p>
<ul>
<li>生产者使用 LPUSH key value[value&hellip;]将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</li>
<li>消费者使用 RPOP key 依次读取队列的消息，先进先出。</li>
</ul>
<p>潜在性能风险点：</p>
<p>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 RPOP命令(比如使用一个while(1)循环)。如果有新消息写入，RPOP命令就会返回结果，否则，RPOP命令返回空值，再继续循环，</p>
<p>所以，即使没有新消息写入List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 <strong>CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。</strong></p>
<p>为了解决这个问题，Redis提供了 BRPOP 命令。BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。</p>
</li>
<li>
<p>如何处理重复的消息？</p>
<p>消费者要实现重复消息的判断，需要2个方面的要求:</p>
<ul>
<li>每个消息都有一个全局的ID。</li>
<li>消费者要记录已经处理过的消息的ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。</li>
</ul>
<p>但是 <strong>List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID</strong>，生成之后我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p>
</li>
<li>
<p>如何保证消息的可靠性？</p>
<p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从List 中读取消息了。</p>
<p>为了留存消息，List类型提供了 BRPOPLPUSH 命令，这个命令<strong>的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List(可以叫作备份 List)留存</strong>。</p>
<p>这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p>
<h5 id="总结">总结
</h5><p>基于 List 类型的消息队列，满足消息队列的三大需求(消息保序、处理重复的消息和保证消息可靠性)。</p>
<ul>
<li>消息保序:使用 LPUSH+RPOP;</li>
<li>阻塞读取:使用 BRPOP;</li>
<li>重复消息处理:生产者自行实现全局唯- ID;</li>
<li>消息的可靠性:使用 BRPOPLPUSH</li>
</ul>
<h5 id="list做消息队列的缺陷">List做消息队列的缺陷
</h5><p><strong>List 不支持多个消费者消费同一条消息</strong>，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了无法被其它消费者再次消费。</p>
<p>要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 <strong>List 类型并不支持消费组的实现</strong>。</p>
<p>这就要说起 Redis 从 5.0 版本开始提供的 Stream 数据类型了，Stream 同样能够满足消息队列的三大需求，而且它还支持「消费组」形式的消息读取。</p>
</li>
</ol>
<h2 id="hash">Hash
</h2><h3 id="介绍-2">介绍
</h3><p>Hash 是一个键值对(key-value)集合，其中 value 的形式如:value=[{field1,value1},&hellip;{fieldN,valueN}]。Hash 特别适合用于存储对象。</p>
<h3 id="内部实现-2">内部实现
</h3><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的:</p>
<p>如果哈希类型元素个数小于 512 个，所有值小于64 字节的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构;</p>
<p>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构,</p>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p>
<h3 id="常用操作-2">常用操作
</h3><ul>
<li>hset key field value:指定一个 key，设置字段名所对应的值</li>
<li>hget key field:获取指定 key 和字段对应的值(也可以批量添加)，成功返回操作成功的字段数量</li>
<li>hmset key field value [field value&hellip;]:批量设置某个 key 的字段和对应值，成功返回 OKhmget key filed [filed&hellip;]:批量返回某个 key 中指定的字段和其对应值</li>
<li>hgetall key:用于返回一个 hash 中全部的字段和值</li>
<li>hexists key field:是否存在某个字段</li>
<li>hdel key field:删除 key 中的字段，可以删除所有字段，如果删除所有字段，相当于删除了这个 key</li>
<li>hincrby key filed n:增减操作，hash 中没有类似 decrby 的命令，如果想要减值就直接用负数</li>
<li>hkeys key:获取所有的字段值</li>
<li>hvals key:获取所有的值</li>
</ul>
<h3 id="应用场景-2">应用场景
</h3><h4 id="缓存对象-1">缓存对象
</h4><p>Hash 类型的(key，field， value)的结构与对象的(对象id，属性，值)的结构相似，也可以用来存储对象。</p>
<p>在介绍 String 类型的应用场景时有所介绍，String +Json也是存储对象的一种方式，那么存储对象时，到底用 String + json 还是用 Hash 呢?</p>
<p>一般对象用 String +Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。</p>
<h4 id="购物车">购物车
</h4><p>以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素。</p>
<p>涉及的命令如下:</p>
<ul>
<li>添加商品:HSET cart:{用户id}{商品id} 1</li>
<li>添加数量:HINCRBY cart:f用户id}{商品id} 1</li>
<li>商品总数:HLEN cart:{用户id}</li>
<li>删除商品:HDEL cart:{用户id}{商品id}</li>
<li>获取购物车所有商品: HGETALL cart:{用户id}</li>
</ul>
<p>当前仅仅是将商品ID存储到了Redis 中，在回显商品具体信息的时候，还需要拿着商品 id 查询一次数据库，获取完整的商品的信息。</p>
<h2 id="set">Set
</h2><h3 id="介绍-3">介绍
</h3><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<p>一个集合最多可以存储 2^32-1 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p>
<p>Set 类型和 List 类型的区别如下:</p>
<ul>
<li>List 可以存储重复元素，Set 只能存储非重复元素;</li>
<li>List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。</li>
</ul>
<h3 id="内部实现-3">内部实现
</h3><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 512个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构;</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<h3 id="常用操作-3">常用操作
</h3><ul>
<li>sadd:添加新元素，元素存在则忽略，key不存在则新建</li>
<li>smembers:列出集合中所有元素</li>
<li>sismember:判断元素是否在集合中</li>
<li>scard:返回集合中元素个数</li>
<li>srem:移除集合中一个或多个元素，如果移除的不存在就不处理</li>
<li>sinter:对两个集合求交集</li>
<li>sunion:对两个集合求并集</li>
<li>sdiff:对两个集合求差集</li>
<li>setnx:向 Redis 中添加一个 key，只用当 key 不存在的时候才添加并返回 1，存在则不添加返回 0</li>
</ul>
<h3 id="应用场景-3">应用场景
</h3><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p>
<p>因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p>
<p>但是这里有一个潜在的风险。<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。</strong></p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算(交集、差集、并集)时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p>
<h4 id="点赞">点赞
</h4><p>Set 类型可以保证一个用户只能点一个赞。</p>
<p>key 是文章id，value 是用户id</p>
<h4 id="共同关注">共同关注
</h4><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<p>key 可以是用户id，value 则是已关注的公众号的id。</p>
<h4 id="抽奖活动">抽奖活动
</h4><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p>
<h2 id="zset">Zset
</h2><h3 id="介绍-4">介绍
</h3><p>Zset 类型(有序集合类型)相比于 Set 类型多了一个排序属性 score(分值)，对于有序集合 ZSet 来说每个存储元素相当于有两个值组成的，一个是有集合的元素值，一个是排序值。</p>
<p>有序集合保留了集合不能有重复成员的特性(分值可以重复)，但不同的是，有序集合中的元素可以排序。</p>
<h3 id="内部实现-4">内部实现
</h3><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的:</p>
<p>如果有序集合的元素个数小于 128个，并且每个元素的值小于 64字节时，Redis 会使用<strong>压缩列表</strong></p>
<p>作为 Zset 类型的底层数据结构:</p>
<p>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构;</p>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p>
<h3 id="常用操作-4">常用操作
</h3><ul>
<li>
<p>zadd:新增一个有序集合，并加入一个元素</p>
</li>
<li>
<p>zrange:列出有序集合中的元素</p>
</li>
<li>
<p>zrem:从有序集合中删除元素</p>
</li>
<li>
<p>zcard:返回有序集合中的数量</p>
<p>注意：相比于Set类型，Zset类型没有支持差集运算</p>
</li>
</ul>
<h3 id="应用场景-4">应用场景
</h3><p>Zset 类型(Sorted Set，有序集合)可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p>
<p>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用Sorted Set.</p>
<h4 id="排行榜">排行榜
</h4><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p>
<h4 id="电话姓名排序">电话、姓名排序
</h4><p>使用有序集合的ZRANGEBYLEX或ZREVRANGEBYLEX可以帮助我们实现电话号码或姓名的排序，我们以(返回指定成员区间内的成员，按 key 正序排列，分数必须相同)为例。ZRANGEBYLEX</p>
<p><strong>注意:不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。</strong></p>
<h1 id="redis数据结构">Redis数据结构
</h1><p>这里主要讲解Redis键值对中值的数据类型，也就是数据的保存形式，其底层实现的方式的数据结构。</p>
<p><img src="/image/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%af%b9%e5%ba%94%e5%9b%be.png"
	
	
	
	loading="lazy"
	
		alt="数据结构对应图"
	
	
></p>
<h2 id="键值对数据库是怎么实现的">键值对数据库是怎么实现的？
</h2><p>Redis 是怎样实现键值对(key-value)数据库的。</p>
<p>Redis 的键值对中的 key 就是字符串对象，而 <strong>value 可以是字符串对象，也可以是集合数据类型的对象</strong></p>
<p>比如 List 对象、Hash 对象、Set 对象和 Zset 对象。</p>
<p>举个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; SET name &#34; 隔壁老王&#34;
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt; HSET person name &#34;楼下老吴&#34; age 18
</span></span><span class="line"><span class="cl">0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt; RPUSH stu &#34;小帅&#34; &#34;小美&#34;
</span></span><span class="line"><span class="cl">(integer) 4
</span></span></code></pre></td></tr></table>
</div>
</div><p>这些命令代表着:</p>
<ul>
<li>第一条命令:name 是一个<strong>字符串键</strong>，因为键的<strong>值是一个字符串对象</strong>;</li>
<li>第二条命令:person 是一个<strong>哈希表键</strong>，因为键的<strong>值是一个包含两个键值对的哈希表对象</strong>,</li>
<li>第三条命令:stu 是一个<strong>列表键</strong>，因为键的<strong>值是一个包含两个元素的列表对象</strong>;</li>
</ul>
<p>这些键值对是如何保存在 Redis 中的呢?</p>
<p>Redis 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p>
<p>Redis 的哈希桶是怎么保存键值对数据的呢?</p>
<p>哈希桶存放的是指向键值对数据的指针(dictEntry&quot;<em>)，这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身而是保存了 void * key 和 void</em>value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。</p>
<p>Redis 保存键值对所涉及到的数据结构</p>
<p><img src="/image/%e4%bf%9d%e5%ad%98%e9%94%ae%e5%80%bc%e5%af%b9%e6%b6%89%e5%8f%8a%e5%88%b0%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针;</li>
<li>dict 结构，结构体里存放了2个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash的时候才用;</li>
<li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构(dictEntry)的指针;</li>
<li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 **void<em>key 和 void</em>value 指针， <strong>key 指向的是 String 对象，而 value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash对象、Set 对象和 Zset 对象</strong>。</li>
</ul>
<p>特别说明下，void<em>key 和 void</em>value 指针指向的是 <strong>Redis 对象</strong>，Redis 中的每个对象都由 redisObject结构表示。</p>
<p>对象结构里包含的成员变量:</p>
<ul>
<li>type，标识该对象是什么类型的对象(String 对象、 List 对象、Hash 对象、Set对象和 Zset 对象);</li>
<li>encoding，标识该对象使用了哪种底层的数据结构;</li>
<li><strong>ptr，指问底层数据结构的指针，</strong></li>
</ul>
<p>Redis 键值对数据库的全景图</p>
<p><img src="/image/%e5%85%a8%e6%99%af%e5%9b%be.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="sds">SDS
</h2><p>Redis 的String 数据类型的底层数据结构是 SDS。</p>
<p>之所以设计SDS结构来表示字符串是因为C语言的char*字符数组有以下缺陷：</p>
<ol>
<li>char*指针只是指向字符数组的起始位置，而<strong>字符数组的结尾位置就是用&quot;\0&quot;表示，意思是指字符串的结束</strong>。因此<strong>C语言获取字符串长度的时间复杂度是O(N)（这是一个可以改进的地方）</strong>。</li>
<li><strong>字符串里面不能含有“\0”字符</strong>，否则最先被程序读入的“\0”字符将被误认为是字符串结尾，这个限制使得C语言的字符串只能保存文本数据，<strong>不能保存像图片、音频、视频文化这样的二进制数据(这也是一个可以改进的地方)</strong>。</li>
<li><strong>C语言的字符串是不会记录自身的缓冲区大小的</strong>，所以 strcat 函数假定程序员在执行这个函数时，已经为dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而<strong>一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，(这是一个可以改进的地方)</strong>。</li>
</ol>
<p>Redis实现的SDS结构可以将上述问题解决。</p>
<h3 id="sds结构设计">SDS结构设计
</h3><p>结构中的每个成员变量分别介绍下:</p>
<ul>
<li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O(1)。</li>
<li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过a11oc-len 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小,也不会出现前面所说的缓冲区溢出的问题。</li>
<li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了5种类型，分别是sdshdr5、sdshdr8、sdshdr16、sdshdr32和 sdshdr64。</li>
<li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li>
</ul>
<p>总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据:len、aloc、flags，用来解决 C语言字符串的缺陷。</p>
<p>因此有以下几个优点：</p>
<ol>
<li>O(1)复杂度获取字符串长度
SDS 结构因为加入了 len 成员变量，那么<strong>获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O(1)。</strong></li>
<li>二进制安全
SDS 不需要用 “\0”字符来标识字符串结尾了，而是<strong>有个专门的 len 成员变量来记录长度，所以可存储包含“\0”的数据</strong>。</li>
<li>不会发生缓存区溢出
<strong>当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小</strong>，且分配额外的「未使用空间」<strong>有效的减少内存分配次数</strong>。</li>
<li>节省内存空间
<strong>不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>，并取消了结构体在编译过程中的内存对齐。</li>
</ol>
<h2 id="链表">链表
</h2><h3 id="链表节点结构设计">链表节点结构设计
</h3><p>有前置节点和后置节点，为双向链表。</p>
<h3 id="链表结构设计">链表结构设计
</h3><p>Redis在listNode结构体的基础上又封装了list这个数据结构，这样操作起来会更方便。链表结构为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef struct list {
</span></span><span class="line"><span class="cl">    //链表头节点
</span></span><span class="line"><span class="cl">    listNode thead;
</span></span><span class="line"><span class="cl">    //链表尾节点
</span></span><span class="line"><span class="cl">    listNode
</span></span><span class="line"><span class="cl">    *tail;
</span></span><span class="line"><span class="cl">    //节点值复制函数
</span></span><span class="line"><span class="cl">    void
</span></span><span class="line"><span class="cl">    (*dup)(void
</span></span><span class="line"><span class="cl">    *ptr);
</span></span><span class="line"><span class="cl">    //节点值释放函数
</span></span><span class="line"><span class="cl">    void (*free)(void
</span></span><span class="line"><span class="cl">    *ptr);
</span></span><span class="line"><span class="cl">    //节点值比较函数
</span></span><span class="line"><span class="cl">    int (*match)(void *ptr, void *key);
</span></span><span class="line"><span class="cl">    //链表节点数量
</span></span><span class="line"><span class="cl">    unsigned long len;
</span></span><span class="line"><span class="cl">} list;
</span></span></code></pre></td></tr></table>
</div>
</div><p>list结构为链表提供了链表头指针head、链表尾节点tail、链表节点数量len、以及可以自定义实现的dup、free、match函数。</p>
<h3 id="链表的优势与缺陷">链表的优势与缺陷
</h3><p>Redis的链表实现优点如下：</p>
<ul>
<li>listNode 链表节点的结构里带有 prev 和 next 指针，<strong>获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</strong>;</li>
<li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以<strong>获取链表的表头节点和表尾节点的时间复杂度只需O(1)</strong>;</li>
<li>list 结构因为提供了链表节点数量 len，所以<strong>获取链表中的节点数量的时间复杂度只需O(1)</strong>;</li>
<li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，<strong>因此链表节点可以保存各种不同类型的值</strong>；</li>
</ul>
<p>链表的缺陷：</p>
<ul>
<li>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用CPU 缓存来加速访问。</li>
<li>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。</li>
</ul>
<p>因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。</p>
<p>不过，压缩列表存在性能问题，所以 Redis 在 3.2 版本设计了新的数据结构quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。</p>
<p>然后在 Redis 5.0 设计了新的数据结构listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 listpack 实现。</p>
<h2 id="压缩列表">压缩列表
</h2><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p>
<p>但是，压缩列表的缺陷也是有的:</p>
<ul>
<li>不能保存过多的元素，否则查询效率就会降低;</li>
<li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li>
</ul>
<p>因此，Redis 对象(List 对象、Hash 对象、Zset 对象)包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。</p>
<h3 id="压缩列表结构设计">压缩列表结构设计
</h3><p>压缩列表是Redis为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。</p>
<p>压缩列表在表头有三个字段：</p>
<ul>
<li><strong>zlbytes</strong>，记录整个压缩列表占用对内存字节数;</li>
<li><strong>zltail</strong>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量</li>
<li><strong>zllen</strong>，记录压缩列表包含的节点数量;</li>
<li><strong>zlend</strong>，标记压缩列表的结束点，固定值 0xFF(十进制255)</li>
</ul>
<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段(zllen)的长度直接定位，复杂度是 0(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是O(N)了，因此压缩列表不适合保存过多的元素</strong>。</p>
<p>压缩列表节点（entry）包含三部分内容：</p>
<ul>
<li><strong>prevlen</strong>，记录了「前一个节点」的长度，目的是为了实现从后向前遍历;</li>
<li><strong>encoding</strong>，记录了当前节点实际数据的「类型和长度」，类型主要有两种:字符串和整数。</li>
<li><strong>data</strong>，记录了当前节点的实际数据，类型和长度都由encoding 决定;</li>
</ul>
<p>当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 preven 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的。</strong></p>
<p>分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。</p>
<p>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度|，而且 prevlen 属性的空间大小</p>
<p>跟前一个节点长度值有关，比如:</p>
<ul>
<li>如果前一个节点的长度小于 254 字节，那么 preven 属性需要用1字节的空间来保存这个长度值;</li>
<li>如果前一个节点的长度大于等于 254 字节，那么 previen 属性需要用5 字节的空间来保存这个长度值;</li>
</ul>
<p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关。</p>
<ul>
<li>如果<strong>当前节点的数据是整数</strong>，则 encoding 会使用<strong>1字节的空间</strong>进行编码，也就是 encoding 长度为 1字节。通过 encoding 确认了整数类型，就可以确认整数数据的实际大小了，比如如果 encoding 编码确认了数据是 int16 整数，那么 data 的长度就是 int16 的大小。</li>
<li>如果<strong>当前节点的数据是字符串，根据字符串的长度大小</strong>，encoding 会使用<strong>1字节/2字节/5字节的空间</strong>进行编码，encoding 编码的前两个 bit 表示数据的类型，后续的其他 bit 标识字符串数据的实际长度即 data 的长度。</li>
</ul>
<h3 id="压缩列表的缺陷">压缩列表的缺陷
</h3><p>空间扩展操作也就是重新分配内存，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能。</strong></p>
<p>所以说，<strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题。</strong></p>
<p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p>
<p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构:quicklist(Redis 3.2 引入)和 listpack(Redis 5.0 引入)。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。</p>
<h4 id="连锁更新问题">连锁更新问题
</h4><p><strong>压缩列表新增某个元素或修改某个元素时，如果空间不够，压缩列表占用的内存空间就需要重新分配,而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。</strong></p>
<p><strong>这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」</strong>，就像多米诺牌的效应一样。</p>
<h2 id="哈希表">哈希表
</h2><p>哈希表是一种保存键值对(key-value)的数据结构。</p>
<p>哈希表中的每一个 key 都是独一无二的，程序可以根据 key 查找到与之关联的 value，或者通过 key 来更新 value，又或者根据 key 来删除整个 key-value等等。</p>
<p>优点：<strong>以 O(1)的复杂度快速查询数据</strong>。</p>
<p>缺点：在哈希表大小固定的情况下，随着数据不断增多，那么<strong>哈希冲突</strong>的可能性也会越高。</p>
<p><strong>Redis 采用了「链式哈希」来解决哈希冲突</strong>，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接起，以便这些数据在表中仍然可以被查询到。</p>
<h3 id="哈希表结构设计">哈希表结构设计
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef struct dictht {
</span></span><span class="line"><span class="cl">    //哈希表数组
</span></span><span class="line"><span class="cl">    dictEntry
</span></span><span class="line"><span class="cl">    table;
</span></span><span class="line"><span class="cl">    //哈希表大小
</span></span><span class="line"><span class="cl">    unsigned long size;
</span></span><span class="line"><span class="cl">    //哈希表大小掩码,用于计算索引值
</span></span><span class="line"><span class="cl">    unsigned long sizemask;
</span></span><span class="line"><span class="cl">    //该哈希表已有的节点数量
</span></span><span class="line"><span class="cl">    unsigned long used;
</span></span><span class="line"><span class="cl">}dictht;
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，哈希表是一个数组(dictEntry **table)，数组的每个元素是一个指向「哈希表节点(dictEntry)」的指针。</p>
<p><img src="/image/%e5%93%88%e5%b8%8c%e8%a1%a8.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>哈希表节点的结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef struct dictEntry {
</span></span><span class="line"><span class="cl">    //键值对中的键
</span></span><span class="line"><span class="cl">    void *key;
</span></span><span class="line"><span class="cl">    //键值对中的值
</span></span><span class="line"><span class="cl">    union (
</span></span><span class="line"><span class="cl">    void *val;
</span></span><span class="line"><span class="cl">    uint64_t u64;
</span></span><span class="line"><span class="cl">    int64_t s64;
</span></span><span class="line"><span class="cl">    double d;
</span></span><span class="line"><span class="cl">    } v;
</span></span><span class="line"><span class="cl">    //指向下一个哈希表节点,形成链表
</span></span><span class="line"><span class="cl">    struct dictEntry next;
</span></span><span class="line"><span class="cl">} dictentry;
</span></span></code></pre></td></tr></table>
</div>
</div><p>dictEntry 结构里不仅包含指向键和值的指针，还包含了指向下一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接起来，以此来解决哈希冲突的问题，这就是链式哈希。</p>
<h3 id="哈希冲突">哈希冲突
</h3><p>哈希表实际上是一个数组，数组里的每一个元素就是一个哈希桶。</p>
<p>当一个键值对的键经过 Hash 函数计算后得到哈希值，再将(哈希值 % 哈希表大小)取模计算，得到的结果值就是该 key-value 对应的数组元素位置，也就是第几个哈希桶。、</p>
<h4 id="什么是哈希冲突呢">什么是哈希冲突呢
</h4><p>举个例子，有一个可以存放8个哈希桶的哈希表。key1 经过哈希函数计算后，再将「哈希值%8」进行取模计算，结果值为 1，那么就对应哈希桶 1，类似的，key9 和 key10 分别对应哈希桶1和桶 6。</p>
<p>此时，key1 和 key9 对应到了相同的哈希桶中，这就发生了哈希冲突。</p>
<p>因此，<strong>当有两个以上数量的 kay 被分配到了哈希表中同一个哈希桶上时，此时称这些 key 发生了冲突。</strong></p>
<h3 id="链式哈希">链式哈希
</h3><p>Redis采用了链式哈希的方法解决哈希冲突。</p>
<h4 id="链式哈希怎么实现的">链式哈希怎么实现的？
</h4><p>实现的方式就是每个哈希表节点都有一个 next 指针，用于指向下一个哈希表节点，因此多个哈希表节点可以用 next 指针构成一个单项链表，<strong>被分配到同一个哈希桶上的多个节点可以用这个单项链表连接起来，这样就解决了哈希冲突。</strong></p>
<p>还是用前面的哈希冲突例子，key1 和 key9 经过哈希计算后，都落在同一个哈希桶，链式哈希的话，key1就会通过 next 指针指向 key9，形成一个单向链表。</p>
<p>不过，链式哈希局限性也很明显，随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O(n)。</p>
<p>要想解决这一问题，就需要进行rehash，也就是对哈希表的大小进行扩展。</p>
<h3 id="rehash">rehash
</h3><p>在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了两个哈希表(ht[2])。</p>
<p>之所以定义了两个哈希表，是因为进行rehash的时候，需要用上两个哈希表。</p>
<p>在正常服务请求阶段，插入的数据，都会写入到「哈希表1」，此时的「哈希表2」 并没有被分配空间。</p>
<p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步:</p>
<ul>
<li>·给「哈希表 2」分配空间，一般会比「哈希表1」大一倍(两倍的意思);</li>
<li>将「哈希表1」的数据迁移到「哈希表 2」 中;</li>
<li>迁移完成后，「哈希表1」的空间会被释放，并把「哈希表 2」设置为「哈希表1」，然后在「哈希表2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li>
</ul>
<p>这个过程看起来简单，但是其实第二步很有问题，<strong>如果哈希表1的数据非常庞大，那么在迁移至哈希表2的时候，因为会涉及大量的数据拷贝，此时可能会对Redis造成阻塞，无法服务其他请求。</strong></p>
<h3 id="渐进式rehash">渐进式rehash
</h3><p>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了渐进式 rehash，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p>
<p>渐进式 rehash 步骤如下:</p>
<ul>
<li>给「哈希表 2」分配空间;</li>
<li><strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表1」中索引位置上的所有 key-value 迁移到「哈希表 2」 上;</strong></li>
<li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表1」的所有 keyvalue 迁移到「哈希表 2」，从而完成 rehash 操作。</li>
</ul>
<p>这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash的耗时操作。</p>
<p>在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。</p>
<p>比如，查找一个 key 的值的话，先会在「哈希表1」里面进行查找，如果没找到，就会继续到哈希表2里面进行找到。</p>
<p>另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表2」里面，而「哈希表1」则不再进行任何添加操作，这样保证了「哈希表1」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表1」就会变成空表，</p>
<p>而rehash 的触发条件跟**负载因子(load factor)**有关系。</p>
<p>负载因子可以通过下面这个公式计算:
</p>
$$
                            负载因子 = 哈希表已保存节点数量 / 哈希表大小
$$<p>
触发 rehash 操作的条件，主要有两个:</p>
<ul>
<li><strong>当负载因子大于等于1，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li>
<li><strong>当负载因子大于等于5时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong></li>
</ul>
<h2 id="整数集合">整数集合
</h2><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。</p>
<h3 id="整数集合结构设计">整数集合结构设计
</h3><p>整数集合的本质是一块连续内存空间，它的结构定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef struct intset {
</span></span><span class="line"><span class="cl">    //编码方式
</span></span><span class="line"><span class="cl">    uint32_t encoding
</span></span><span class="line"><span class="cl">    //集合包含的元素数量
</span></span><span class="line"><span class="cl">    uint32 t length;
</span></span><span class="line"><span class="cl">    //保存元素的数组
</span></span><span class="line"><span class="cl">    int8_t contents[];
</span></span><span class="line"><span class="cl">}intset;
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，保存元素的容器是一个 contents 数组，虽然 contents 被声明为 int8_t类型的数组，但是实际上 contents 数组并不保存任何 int8_t 类型的元素，contents 数组的真正类型取决于 intset 结构体里的encoding 属性的值。比如:</p>
<ul>
<li>如果 encoding 属性值为 INTSET_ENC INT16，那么 contents 就是一个 int16_t类型的数组，数组中每一个元素的类型都是 int16_t;</li>
<li>如果 encoding 属性值为 INTSET_ENC_INT32，那么 contents 就是一个 int32_t类型的数组，数组中每一个元素的类型都是 int32_t;</li>
<li>如果 encoding 属性值为 INTSET_ENC_INT64，那么 contents 就是一个 int64_t类型的数组，数组中每-个元素的类型都是 int64_t;</li>
</ul>
<p>不同类型的 contents 数组，意味着数组的大小也会不同。</p>
<h3 id="整数集合的升级操作">整数集合的升级操作
</h3><p>整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型(int32_t)比整数集合现有所有元素的类型(int16_t)都要长时，整数集合需要先进行升级，也就是按新元素的类型(int32_t)扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。</p>
<p><strong>整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割，如果 encoding 属性值为 INTSET_ENC_INT16，则每个元素的间隔就是 16 位。</strong></p>
<h4 id="整数集合升级有什么好处呢">整数集合升级有什么好处呢？
</h4><p>如果要让一个数组同时保存 int16_t、int32_t、int64_t 类型的元素，最简单做法就是直接使用 int64_t 类型的数组。不过这样的话，当如果元素都是 int16_t 类型的，就会造成内存浪费的情况。</p>
<p>整数集合升级就能避免这种情况，如果一直向整数集合添加 int16_t 类型的元素，那么整数集合的底层实现就一直是用 int16_t 类型的数组，只有在我们要将 int32_t 类型或 int64_t 类型的元素添加到集合时，才会对数组进行升级操作。</p>
<p>因此，整数集合升级的好处是节省内存资源。</p>
<h4 id="整数集合支持降级操作吗">整数集合支持降级操作吗？
</h4><p><strong>不支持降级操作</strong>，一旦对数组进行了升级，就会一直保持升级后的状态。</p>
<h2 id="跳表">跳表
</h2><p>Redis 只有 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p>
<p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef struct zset {
</span></span><span class="line"><span class="cl">    dict *dict;
</span></span><span class="line"><span class="cl">    zskiplist *zsl;
</span></span><span class="line"><span class="cl">} zset;
</span></span></code></pre></td></tr></table>
</div>
</div><p>set 对象在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新相应的数据，从而保证了跳表和哈希表中记录的信息一致。</p>
<p>Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了<strong>跳表</strong>，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了<strong>哈希表</strong>进行索引。</p>
<p>虽然Zset 对象在使用跳表作为数据结构的时候，是使用由「哈希表+跳表」组成的 struct zset，但是struct zset 中的哈希表只是用于以常数复杂度获取元素权重，其余大部分操作都是跳表实现的。</p>
<h3 id="跳表结构设计">跳表结构设计
</h3><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p>
<p>图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：</p>
<ul>
<li>L0 层级共有 5 个节点，分别是节点1、2、3、4、5；</li>
<li>L1 层级共有 3 个节点，分别是节点 2、3、5；</li>
<li>L2 层级只有 1 个节点，也就是节点 3 。</li>
</ul>
<p>如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。</p>
<p>可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。</p>
<p>跳表节点数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef struct zskiplistNode {
</span></span><span class="line"><span class="cl">    //Zset 对象的元素值
</span></span><span class="line"><span class="cl">    sds ele
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">    //元素权重值
</span></span><span class="line"><span class="cl">    double score;
</span></span><span class="line"><span class="cl">    //后向指针
</span></span><span class="line"><span class="cl">    struct zskiplistNode *backward;
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    //节点的level数组，保存每层上的前向指针和跨度
</span></span><span class="line"><span class="cl">    struct zskiplistLevel {
</span></span><span class="line"><span class="cl">        struct zskiplistNode *forward;
</span></span><span class="line"><span class="cl">        unsigned long span;
</span></span><span class="line"><span class="cl">    } level[];
</span></span><span class="line"><span class="cl">} zskiplistNode;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Zset 对象要同时保存「元素」和「元素的权重」，对应到跳表节点结构里就是 sds 类型的 ele 变量和 double 类型的 score 变量。每个跳表节点都有一个后向指针（struct zskiplistNode *backward），指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</p>
<p>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的zskiplistLevel 结构体类型的 level 数组。</p>
<p>level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。</p>
<p>**跨度实际上是为了计算这个节点在跳表中的排位。**具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。</p>
<p>跳表结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef struct zskiplist {
</span></span><span class="line"><span class="cl">    struct zskiplistNode *header, *tail;
</span></span><span class="line"><span class="cl">    unsigned long length;
</span></span><span class="line"><span class="cl">    int level;
</span></span><span class="line"><span class="cl">} zskiplist;
</span></span></code></pre></td></tr></table>
</div>
</div><p>跳表结构里包含了：</p>
<ul>
<li>跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；</li>
<li>跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；</li>
<li>跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；</li>
</ul>
<h3 id="跳表节点查询过程">跳表节点查询过程
</h3><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p>
<ul>
<li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li>
<li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li>
</ul>
<p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p>
<h3 id="跳表节点层数设置">跳表节点层数设置
</h3><p>跳表的相邻两层的节点数量的比例会影响跳表的查询性能。</p>
<p><strong>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)。</strong></p>
<h4 id="那怎样才能维持相邻两层的节点数量的比例为-2--1-呢">那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？
</h4><p>如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。</p>
<p>Redis 则采用一种巧妙的方法是，<strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p>
<p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数。</strong></p>
<p>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</p>
<p>虽然我前面讲解跳表的时候，图中的跳表的「头节点」都是 3 层高，<strong>但是其实如果层高最大限制是 64，那么在创建跳表「头节点」的时候，就会直接创建 64 层高的头节点</strong>。</p>
<h3 id="为什么用跳表而不用平衡树">为什么用跳表而不用平衡树？
</h3><p>主要是从内存占用、对范围查找的支持、实现难易程度这三方面总结的原因：</p>
<ul>
<li>**从内存占用上来比较，跳表比平衡树更灵活一些。**平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1/(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
<li>**在做范围查找的时候，跳表比平衡树操作要简单。**在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li>
<li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
</ul>
<h2 id="quicklist">quicklist
</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。</p>
<p>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p>
<p>在前面讲压缩列表的时候，我也提到了压缩列表的不足，虽然压缩列表是通过紧凑型的内存布局节省了内存开销，但是因为它的结构设计，如果保存的元素数量增加，或者元素变大了，压缩列表会有「连锁更新」的风险，一旦发生，会造成性能下降。</p>
<p>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p>
<h2 id="listpack">listpack
</h2><p>quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。</p>
<p>因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。</p>
<p>于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p>
<p><strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题。</strong></p>
<hr>
<blockquote>
<p>图片出处为小林coding</p>
</blockquote>
<h1 id="aof持久化">AOF持久化
</h1><p>AOF文件的内容是操作命令</p>
<h2 id="aof日志">AOF日志
</h2><p>其思想是Redis每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里，重启 Redis 的时候，先去读取这个文件里的命令，并且执行它，就相当于恢复了缓存数据了。</p>
<p>客户端发送写命令到Redis。第一步执行写命令到内存；第二步记录命令到日志，日志存放到硬盘。</p>
<p>这种保存写操作命令到日志的持久化方式，就是Redis里的<strong>AOF</strong>（Append Only File）持久化功能，<strong>注意只会记录写操作命令，读操作命令是不会被记录的</strong>，因为没意义。</p>
<p>在Redis中AOF持久化功能默认是不开启的。</p>
<p>AOF日志文件其实就是普通的文本，我们可以通过cat命令查看里面的内容，但其中记录的内容有一定的阅读规则。</p>
<p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">*3
</span></span><span class="line"><span class="cl">$3
</span></span><span class="line"><span class="cl">set
</span></span><span class="line"><span class="cl">$4
</span></span><span class="line"><span class="cl">name
</span></span><span class="line"><span class="cl">$7xiaoxin
</span></span></code></pre></td></tr></table>
</div>
</div><p>「*3」表示当前命令有三个部分，每部分都是以「$+数字」开头，后面紧跟着具体的命令、键或值。然后，这里的「数字」表示这部分中的命令、键或值一共有多少字节。例如，「$3 set」表示这部分有 3 个字节，也就是「set」命令这个字符串的长度。</p>
<p>Redis先执行写操作命令后，再将命令记录到AOF日志里，有以下两个好处：</p>
<ol>
<li>
<p><strong>避免额外的检查开销</strong></p>
<p>因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</p>
<p>而如果先执行写操作命令再记录日志的话，只有在该命令执行成功后，才将命令记录到 AOF 日志里，这样就不用额外的检查开销，保证记录在 AOF 日志里的命令都是可执行并且正确的。</p>
</li>
<li>
<p><strong>不会阻塞当前写操作命令的执行</strong>
当写操作命令执行成功后，才会将命令记录到 AOF 日志。</p>
</li>
</ol>
<p>两个风险：</p>
<ol>
<li>执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有<strong>丢失的风险</strong>。</li>
<li>写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是<strong>可能会给「下一个」命令带来阻塞风险</strong>。因为将命令写入到日志的这个操作也是在主进程完成的（执行命令也是在主进程），也就是说这两个操作是同步的。如果在将日志内容写入到硬盘时，服务器的硬盘的 I/O 压力太大，就会导致写硬盘的速度很慢，进而阻塞住了，也就会导致后续的命令无法执行。</li>
</ol>
<p>两个风险的共性就是跟「 AOF 日志写回硬盘的时机」有关。</p>
<h2 id="三种写回策略">三种写回策略
</h2><p>Redis写入AOF日志过程：</p>
<p><img src="/image/AOF%e8%bf%87%e7%a8%8b.png"
	
	
	
	loading="lazy"
	
	
></p>
<ol>
<li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。</p>
<ul>
<li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li>
<li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>
<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li>
</ul>
<p>这 3 种写回策略都无法能完美解决「主进程阻塞」和「减少数据丢失」的问题，因为两个问题是对立的，偏向于一边的话，就会要牺牲另外一边，原因如下：</p>
<ul>
<li>Always 策略的话，可以最大程度保证数据不丢失，但是由于它每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以是不可避免会影响主进程的性能；</li>
<li>No 策略的话，是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于 Always 策略性能较好，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。</li>
<li>Everysec 策略的话，是折中的一种方式，避免了 Always 策略的性能开销，也比 No 策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。</li>
</ul>
<p>根据自己的业务场景进行选择：</p>
<ul>
<li>如果要高性能，就选择 No 策略；</li>
<li>如果要高可靠，就选择 Always 策略；</li>
<li>如果允许数据丢失一点，但又想性能高，就选择 Everysec 策略。</li>
</ul>
<p><strong>以上三种策略其实是在控制fsync()函数的调用时机：</strong></p>
<p>如果想要应用程序向文件写入数据后，能立马将数据同步到硬盘，就可以调用 fsync() 函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。</p>
<ul>
<li>Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；</li>
<li>Everysec 策略就会创建一个异步任务来执行 fsync() 函数；</li>
<li>No 策略就是永不执行 fsync() 函数</li>
</ul>
<h2 id="aof重写机制">AOF重写机制
</h2><p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。</p>
<p>如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p>
<p>所以，Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<p>重写工作完成后，就会将新的 AOF 文件覆盖现有的 AOF 文件，这就相当于压缩了 AOF 文件，使得 AOF 文件体积变小了。</p>
<p>然后，在通过 AOF 日志恢复数据时，只用执行这条命令，就可以直接完成这个键值对的写入了。</p>
<p>所以，重写机制的妙处在于，尽管某个键值对被多条写命令反复修改，<strong>最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对</strong>，代替之前记录这个键值对的多条命令，这样就减少了 AOF 文件中的命令数量。最后在重写工作完成后，将新的 AOF 文件覆盖现有的 AOF 文件。</p>
<p><strong>为什么重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去呢？</strong></p>
<p>因为<strong>如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染</strong>，可能无法用于恢复使用。</p>
<p>所以 AOF 重写过程，先重写到新的 AOF 文件，重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响。</p>
<h2 id="aof后台重写">AOF后台重写
</h2><p>写入 AOF 日志的操作虽然是在主进程完成的，因为它写入的内容不多，所以一般不太影响命令的操作。</p>
<p>但重写这个过程其实是很耗时的，因为需要读取所有缓存的键值对数据，并为每个键值对生成一条命令，然后将其写入到新的 AOF 文件。所以重写的操作不能放在主进程里。</p>
<p>因此，Redis 的<strong>重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的</strong>，这么做可以达到两个好处：</p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li>
<li>子进程带有主进程的<strong>数据副本</strong>，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li>
</ul>
<p><strong>子进程是怎么拥有主进程一样的数据副本的呢？</strong></p>
<p>主进程在通过 fork 系统调用生成 bgrewriteaof 子进程时，操作系统会把主进程的「<strong>页表</strong>」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。</p>
<p>这样一来，子进程就共享了父进程的物理内存数据了，这样能够<strong>节约物理内存资源</strong>，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</p>
<p>不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写，最后才会对内存进行写操作，这个过程被称为「<strong>写时复制(Copy On Write)</strong>」。</p>
<p>写时复制顾名思义，<strong>在发生写操作的时候，操作系统才会去复制物理内存</strong>，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。</p>
<h2 id="总结-1">总结
</h2><p>Redis 提供了三种将 AOF 日志写回硬盘的策略，分别是 Always、Everysec 和 No，这三种策略在可靠性上是从高到低，而在性能上则是从低到高。</p>
<p>随着执行的命令越多，AOF 文件的体积自然也会越来越大，为了避免日志文件过大， Redis 提供了 AOF 重写机制，它会直接扫描数据中所有的键值对数据，然后为每一个键值对生成一条写操作命令，接着将该命令写入到新的 AOF 文件，重写完成后，就替换掉现有的 AOF 日志。重写的过程是由后台子进程完成的，这样可以使得主进程可以继续正常处理命令。</p>
<p>用 AOF 日志的方式来恢复数据其实是很慢的，因为 Redis 执行命令由单线程负责的，而 AOF 日志恢复数据的方式是顺序执行日志里的每一条命令，如果 AOF 日志很大，这个「重放」的过程就会很慢了。</p>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2022 - 
        
        2024 刘煜鼎
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.27.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
